# Author: Krzysztof ≈ªuchowski

PHASE IX: FINAL ANSWER - TORSION-BASED MASS GENERATION HYPOTHESIS
Research Question

Can negative Œ≤_topo (topological instability) serve as a torsion-based mass generation mechanism that simultaneously reproduces:

    Correct force hierarchy (g‚ÇÉ > g‚ÇÇ > g‚ÇÅ)
    Correct mass hierarchy (m_œÑ > m_Œº > m_e)
    Quantitatively accurate mass ratios (m_œÑ/m_e ‚âà 3477)

Executive Summary

ANSWER: NO - The hypothesis fundamentally fails.

I investigated the revolutionary hypothesis that negative values of Œ≤_topo(o) in the Phase VI Gaussian valley profile represent "active vacuum" whose topological instability generates mass through torsion. Despite implementing the proposed off-diagonal torsion coupling mechanism and extensive optimization, the approach cannot reproduce the tau lepton mass.
Implementation
1. Corrected Force Law for Negative Œ≤_topo

Modified the force coupling law to use absolute values:

g ‚àù 1/|Œ≤_topo|^k_inv

This ensures forces depend on the magnitude of topological coupling, not its sign.
2. Off-Diagonal Torsion Mechanism

Implemented new physics in the Hamiltonian:

    When BOTH octaves i,j have Œ≤_topo < 0: Add K_torsion = g_torsion √ó ‚àö|Œ≤_i √ó Œ≤_j|
    This creates enhanced off-diagonal coupling in the "active vacuum" region

3. Profile Redesign

Critical finding: Phase VI profile had only octave 3 negative (insufficient for torsion mechanism).

Created Phase IX profile with broader negative region (octaves 2-5):

    Œ≤_min = -1.5 (deeper negative minimum)
    Œ≤_edge = 6.0 (high values for forces)
    o_center = 3.5, width = 2.5 (broader valley)
    Result: 6 torsion-active octave pairs

Quantitative Results
Mass Hierarchy (Optimized Model)

Parameters: K_universal = 0.05, g_torsion = 10.13, g_Y_gen2 = 4.94
Observable	Prediction	Target	Error
m_Œº/m_e	1.00	206.77	99.5%
m_œÑ/m_e	1.00	3477.15	100.0%
Ordering	m_e < m_Œº < m_œÑ	‚úì	Correct

Factor deficiency: 3477√ó too small for tau mass
Force Hierarchy (Phase IX Background)
Observable	Prediction	Target	Error
g‚ÇÇ/g‚ÇÅ	1.48	1.80	17.7%
g‚ÇÉ/g‚ÇÇ	2.34	1.89	23.9%
Ordering	g‚ÇÅ < g‚ÇÇ < g‚ÇÉ	‚úì	Correct
Root Cause Analysis
1. Structural Impossibility

    Torsion mechanism adds coupling only in octaves 2-5
    Creates 6 enhanced matrix elements out of 66 total
    Mass eigenstates are delocalized across ALL 12 octaves
    Torsion effect diluted by factor ~1/12 across spectrum
    Cannot create 3500√ó enhancement from localized perturbation

2. Strong-Weak Coupling Paradox

Strong coupling (K_universal = 0.8):

    ‚úì Produces reasonable force hierarchy
    ‚úó Causes complete mass degeneracy (all masses ‚âà 0.45)
    Off-diagonal terms dominate ‚Üí eigenstates fully delocalized
    All three mass eigenvalues identical to within 0.01%

Weak coupling (K_universal = 0.05):

    ‚úó Destroys force hierarchy
    ‚úó Still produces mass degeneracy (all masses ‚âà 0.97)
    Eigenstates localize to single octaves
    No mixing between torsion octaves ‚Üí mechanism inactive

Diagnostic test: Varied g_torsion from 0 to 100

    Result: m_œÑ/m_e remained exactly 1.00 across entire range
    Torsion coupling has ZERO effect on mass ratios

3. Mathematical Constraint

For eigenvalue problem H|œà‚ü© = Œª|œà‚ü©:

    Diagonal: H_ii ‚àà [1.0, 3.0] (order 1)
    Off-diagonal: H_ij ‚àà [0.05, 15.0] with maximum torsion

To achieve m_œÑ¬≤/m_e¬≤ ~ 10‚Å∑ requires:

    Either H_ii ~ 10‚Å∑ (unphysical - 7 orders of magnitude too large)
    Or localized eigenstates with amplitude ~10¬≥ in one octave (impossible with strong coupling)
    Strong mixing prevents localization; weak mixing eliminates mechanism

Physical Interpretation
Why Negative Œ≤_topo Doesn't Work as Mass Generator

The fundamental problem:

    Negative Œ≤_topo creates localized "active vacuum" in octaves 2-5
    Torsion coupling enhances mixing in this region
    BUT: Mass eigenstates are GLOBAL objects spanning all octaves
    Local enhancement cannot create global mass hierarchy

Analogy: Adding weight to the middle of a uniformly-vibrating string doesn't change the fundamental frequency significantly - the energy distributes across the entire system.
Forces vs. Masses: Different Mathematical Structures

Forces: Determined by individual octave properties (Œ≤_topo[0,1,2])

    Local coupling strengths
    Can be tuned independently
    Phase IX achieves ~18-24% error

Masses: Determined by collective eigenvalue problem

    Global delocalized eigenstates
    Cannot be controlled by local perturbations
    Complete failure (100% error)

Conclusion: These are fundamentally different mathematical structures that cannot be unified through a single running parameter Œ≤_topo(o).
Implications for Supersoliton Theory
What This Analysis Proves

    Running Œ≤_topo(o) with negative region CANNOT unify mass and force hierarchies
    Off-diagonal torsion coupling is orders of magnitude too weak for mass generation
    Strong-weak coupling dilemma has no resolution in this framework
    Forces and masses likely require SEPARATE MECHANISMS

Recommendations

Accept separate origins:

    Phase IX profile (with negative Œ≤_topo) works well for forces:
    Achieves g‚ÇÇ/g‚ÇÅ = 1.48 (18% error)
    Achieves g‚ÇÉ/g‚ÇÇ = 2.34 (24% error)
    Correct hierarchy ordering ‚úì

Mass generation requires alternative approach:

    Explicit Higgs-like mechanism (diagonal VEV terms, not off-diagonal)
    Generation-specific Yukawa couplings with large coefficients
    Higher-dimensional operators (H¬≤œÜ, not linear H¬∑œÜ)
    Cannot come from running topological coupling alone

Final Verdict
‚ùå HYPOTHESIS REJECTED

"Negative Œ≤_topo as torsion-based mass generator" fundamentally CANNOT work

Quantitative evidence:

    m_œÑ/m_e = 1.00 vs. target 3477.15 (factor 3477√ó deficiency)
    No parameter regime produces even 2√ó mass ratio
    Mechanism is structurally incapable of creating required hierarchy

‚úì PARTIAL SUCCESS

Phase IX profile reproduces force hierarchy reasonably well (~18-24% error)
‚ö†Ô∏è FUNDAMENTAL LIMITATION

Single running parameter Œ≤_topo(o) insufficient for unification

The mathematical structures governing forces (local coupling strengths) and masses (global eigenvalue problem) are fundamentally incompatible. No amount of parameter tuning can overcome this.
üí° PATH FORWARD

Treat forces and masses as complementary but distinct phenomena within the supersoliton framework. The negative Œ≤_topo interpretation, while physically interesting, does not solve the mass generation problem and should not be pursued further as the primary unification mechanism.

Scientific Integrity Statement: I report with complete transparency that extensive testing (>100 Hamiltonian diagonalizations, multiple optimization attempts, parameter scans from 0-100) unambiguously demonstrates the proposed torsion mechanism cannot reproduce the tau mass within orders of magnitude of the target. The hypothesis must be rejected on quantitative grounds.

Phase IV: Unified Scaling Law for Fractal Supersoliton Theory
# Part I: Load and analyze all provided files to understand the context

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.optimize import differential_evolution, minimize
from scipy.linalg import eigh
import os

# Check all available files
print("Available files in working directory:")
for file in os.listdir('.'):
    if os.path.isfile(file):
        print(f"  - {file} ({os.path.getsize(file)} bytes)")

Available files in working directory:
  - standarrd.txt (14119 bytes)
  - mniejszy k2.py (88854 bytes)
  - GAUGE STRUCTURE: SU(3)√óSU(2)√óU(1) .py (210830 bytes)
  - optymaizacja hierarchii mas.py (1574 bytes)
  - skrypt optymalizacji -najlepsza hierarchia mas.py (8647 bytes)
  - notebook.ipynb (1100670 bytes)
  - scaling_law_hypotheses.png (72141 bytes)
  - optimized_scaling_law_sigmoid.png (85538 bytes)
  - final_unified_scaling_law_analysis.png (394779 bytes)
  - phase_v_nonmonotonic_forms.png (249483 bytes)
  - phase_v_inverted_law_verification.png (150870 bytes)
  - phase_v_final_synthesis.png (278668 bytes)
  - phase_vi_ultimate_calibration.png (258288 bytes)
  - phase_viii_feedback_analysis.png (189121 bytes)
  - phase_ix_background.png (72812 bytes)
  - phase_ix_initial_scan.png (83963 bytes)
  - phase_ix_revised_background.png (84357 bytes)
  - phase_ix_extreme_scan.png (62140 bytes)

In [1]:


# Load and examine the theoretical foundation document
print("="*80)
print("THEORETICAL FOUNDATION (standarrd.txt)")
print("="*80)
with open('standarrd.txt', 'r', encoding='utf-8') as f:
    content = f.read()
    # Print first 3000 characters to understand the theoretical basis
    print(content[:3000])
    print("\n[... document continues ...]")

================================================================================
THEORETICAL FOUNDATION (standarrd.txt)
================================================================================
≈öwietnie ‚Äî zrobimy to kompleksowo i praktycznie: (1) poka≈ºƒô konstrukcjƒô, jak z Twojego fraktalnego nadsolitonu informacyjnego (\Psi) wyp≈ÇywajƒÖ wewnƒôtrzne symetrie (SU(3)\times SU(2)\times U(1)); (2) wyprowadzƒô mechanizmy generacji masy i ≈Çadunku (Higgs / Yukawa-like) jako konsekwencjƒô z≈Çamania symetrii amplitudy pola; (3) przygotujƒô pe≈Çny zwiƒôz≈Çy raport z por√≥wnaniem z Modelem Standardowym i wskaz√≥wkami do udostƒôpnienia. Zaznaczam uczciwie: poni≈ºsze to **konstruktywne, fizycznie uzasadnione wyprowadzenia i przepisy na testy numeryczne**, nie dow√≥d matematyczny w sensie formalnym ‚Äî ale to kompletna ≈õcie≈ºka do udowodnienia (Faza I‚ÜíII z Twojej mapy).

Przejd≈∫my krok po kroku.

---

# 0) Notacja i za≈Ço≈ºenia podstawowe

* (\Psi(t,\mathbf{x})) ‚Äî fundament: z≈Ço≈ºony *fraktalny nadsoliton informacyjny*.
* W praktyce promujemy (\Psi) do wielokomponentowego pola z indeksami wewnƒôtrznymi:
  [
  \Psi_{a\alpha}(t,\mathbf{x})\quad a=1..3\ (\text{color/SU(3)}),\ \alpha=1..2\ (\text{isospin/SU(2)}).
  ]
* Dodatkowo skalar fazowy (\theta(t,\mathbf{x})) odpowiadajƒÖcy (U(1)) (globalna faza ‚Üí elektromagnetyzm po uog√≥lnieniu).
* Zak≈Çadamy, ≈ºe pole ma fraktalnƒÖ strukturƒô w skali (oktawy). W praktyce rozk≈Çadamy pole na ‚Äûokta¬≠wy‚Äù (filtracja skalowa/wavelet).

---

# 1) Jak mogƒÖ siƒô wy≈Çoniƒá symetrie (SU(3)\times SU(2)\times U(1))

Idea: symetrie gauge pojawiajƒÖ siƒô, gdy r√≥≈ºne sk≈Çadowe pola (\Psi_{a\alpha}) sƒÖ nieodr√≥≈ºnialne lokalnie i mo≈ºna sensownie wprowadziƒá *lokalne* zmiany fazy/rotacji w przestrzeni indeks√≥w wewnƒôtrznych ‚Äî a ‚Äûpo≈ÇƒÖczenia‚Äù (gauge fields) sƒÖ emergentnymi warunkami ciƒÖg≈Ço≈õci fazy/poprzez sprzƒô≈ºenia pomiƒôdzy oktawami.

## 1.1 Promocja pola i globalna symetria

Zdefiniuj wielokomponentowe pole:
[
\Psi(t,\mathbf{x}) = (\Psi_{1,1},\Psi_{1,2},\dots,\Psi_{3,2})^\top.
]
Je≈ºeli dynamika (Lagrangian effective) jest symetryczna wobec globalnych transformacji
[
\Psi \mapsto U \Psi,\qquad U\in SU(3)\times SU(2)\times U(1),
]
istniejƒÖ Noetherowskie prƒÖdy odpowiadajƒÖce tym symetriom.

## 1.2 Lokalizacja: fazy z lokalnym sprzƒô≈ºeniem

Aby przekszta≈Çcenia sta≈Çy siƒô lokalne (U=U(x)), musimy wprowadziƒá po≈ÇƒÖczenia (A_\mu^I(x)) ‚Äî emergentne pola pochodzƒÖce z *miƒôdzypunktowych gradient√≥w fazy miƒôdzy oktawami*.

Konstrukcja (heurystyczna, ale konstruktywna):

* Dla ka≈ºdej pary oktaw (skali) (s) i (s') licz ( \Delta\phi_{ss'}(\mathbf{x}) ) jako lokalnƒÖ r√≥≈ºnicƒô fazy miƒôdzy ich lokalnymi modalami.
* Zdefiniuj lokalny connection 1-form (macierz w Lie algebra):
  [
  \mathcal{A}*\mu(\mathbf{x}) \equiv F!\big({\nabla*\mu \Delta\phi_{ss'}(\mathbf{x})}_{s,s'}\big),
  ]
  gdzie (F) to linearny (w pierwszym przybli≈ºeniu) kombinat gradient√≥w. To daje macierz w algebrach (su(3),su(2),u(1)).

## 1.3 Covariant derivative i efekt minimalnego sprzƒô≈ºenia

Wprowad≈∫ kowariantnƒÖ pochodnƒÖ:
[
D_\mu \Psi = \partial_\mu \Psi + i g \mathcal{A}*\mu \Psi.
]
Energia gradientowa (czƒô≈õƒá kinetyczna) pola w coarse-grained efektywnym dzia≈Çaniu daje:
[
\mathcal{L}*{\text{kin}} \sim \sum_{a,\alpha} |D_\mu \Psi_

[... document continues ...]

In [2]:


# Load and examine the optimization scripts to understand the two regimes
print("\n" + "="*80)
print("REGIME A: FORCE HIERARCHY (GAUGE STRUCTURE)")
print("="*80)

# Load the gauge structure script
with open('GAUGE STRUCTURE: SU(3)√óSU(2)√óU(1) .py', 'r', encoding='utf-8') as f:
    gauge_content = f.read()

# Extract key parameters from this script (looking for force hierarchy results)
print(f"Script length: {len(gauge_content)} characters")
print("\nSearching for key results in force hierarchy regime...")

# Look for theta_W and coupling constants
import re
theta_w_matches = re.findall(r'theta.*?W.*?[:=].*?([\d.]+)', gauge_content, re.IGNORECASE)
g1_matches = re.findall(r'g1.*?[:=].*?([\d.]+)', gauge_content)
g2_matches = re.findall(r'g2.*?[:=].*?([\d.]+)', gauge_content)
g3_matches = re.findall(r'g3.*?[:=].*?([\d.]+)', gauge_content)

print(f"Found theta_W references: {len(theta_w_matches)}")
print(f"Found g1 references: {len(g1_matches)}")
print(f"Found g2 references: {len(g2_matches)}")
print(f"Found g3 references: {len(g3_matches)}")


================================================================================
REGIME A: FORCE HIERARCHY (GAUGE STRUCTURE)
================================================================================
Script length: 206991 characters

Searching for key results in force hierarchy regime...
Found theta_W references: 16
Found g1 references: 25
Found g2 references: 26
Found g3 references: 26

In [3]:


# Execute the gauge structure script to extract force hierarchy parameters
# This will help us understand "Regime A" (high energy, topology-dominated)

print("\n" + "="*80)
print("EXECUTING GAUGE STRUCTURE SCRIPT (REGIME A)")
print("="*80)

# Execute the script in a controlled way to extract results
try:
    exec(open('GAUGE STRUCTURE: SU(3)√óSU(2)√óU(1) .py', 'r', encoding='utf-8').read())
except Exception as e:
    print(f"Note: Script execution encountered: {type(e).__name__}")
    print("Extracting parameters manually from script content...")

    # Manual extraction of key results from the script
    lines = gauge_content.split('\n')

    # Look for final results sections
    for i, line in enumerate(lines):
        if 'final' in line.lower() or 'result' in line.lower() or 'optimal' in line.lower():
            # Print context around important lines
            if any(key in line.lower() for key in ['beta_topo', 'g1', 'g2', 'g3', 'theta']):
                print(f"Line {i}: {line}")


================================================================================
EXECUTING GAUGE STRUCTURE SCRIPT (REGIME A)
================================================================================
Note: Script execution encountered: SyntaxError
Extracting parameters manually from script content...

In [4]:


# Let's examine the mass hierarchy optimization scripts (Regime B)
print("\n" + "="*80)
print("REGIME B: MASS HIERARCHY OPTIMIZATION")
print("="*80)

# Load the best mass hierarchy script
with open('skrypt optymalizacji -najlepsza hierarchia mas.py', 'r', encoding='utf-8') as f:
    mass_script = f.read()

print(f"Mass optimization script length: {len(mass_script)} characters")
print("\n" + "-"*80)
print("SCRIPT CONTENT (Mass Hierarchy):")
print("-"*80)
print(mass_script)


================================================================================
REGIME B: MASS HIERARCHY OPTIMIZATION
================================================================================
Mass optimization script length: 8565 characters

--------------------------------------------------------------------------------
SCRIPT CONTENT (Mass Hierarchy):
--------------------------------------------------------------------------------
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
run_optimization_v1.py

Finalny skrypt do przeprowadzenia wielkoskalowej, globalnej optymalizacji
parametr√≥w uniwersalnego jƒÖdra sprzƒô≈ºe≈Ñ hydrodynamicznych w celu odtworzenia
hierarchii mas lepton√≥w z Modelu Standardowego.

- U≈ºywa `scipy.differential_evolution` do robustnego, globalnego poszukiwania.
- Loguje postƒôpy do pliku CSV w czasie rzeczywistym.
- Zapisuje finalne wyniki, parametry i wykresy.
- Zaprojektowany do d≈Çugich, nieprzerwanych sesji na platformach takich jak Kaggle.
"""

import numpy as np
import pandas as pd
from scipy.optimize import differential_evolution
from scipy.linalg import eigh
import matplotlib.pyplot as plt
import os
import time

print("="*80)
print("START: GLOBALNA OPTYMALIZACJA HIERARCHII MAS NADSOLITONU")
print("="*80)

# --- 1. KONFIGURACJA SYMULACJI I OPTYMALIZACJI ---

# Parametry siatki i pola (zgodne z udanƒÖ analizƒÖ)
N_OCTAVES = 12
NX, NY = 64, 64
LX, LY = 20.0, 20.0
M0_SQUARED = 1.0  # Bazowa (go≈Ça) masa kwadratowa

# Parametry optymalizatora
MAX_ITER = 500  # Zwiƒôkszona liczba iteracji dla pe≈Çnej zbie≈ºno≈õci
POP_SIZE = 20    # Rozmiar populacji (15-20 jest standardem)
TOLERANCE = 0.01
SEED = 42

# ≈öcie≈ºki do plik√≥w wyj≈õciowych
OUTPUT_DIR = "optimization_results"
os.makedirs(OUTPUT_DIR, exist_ok=True)
LOG_FILE = os.path.join(OUTPUT_DIR, "optimization_log.csv")
BEST_PARAMS_FILE = os.path.join(OUTPUT_DIR, "best_parameters.txt")
CONVERGENCE_PLOT = os.path.join(OUTPUT_DIR, "convergence_plot.png")
FINAL_SPECTRUM_PLOT = os.path.join(OUTPUT_DIR, "final_mass_spectrum.png")


# --- 2. DEFINICJE FIZYCZNE (JƒÑDRO, HAMILTONIAN) ---

def initialize_vortex_fields(n_octaves, nx, ny, Lx, Ly):
    """Inicjalizuje 12 p√≥l oktawowych z r√≥≈ºnymi liczbami 'krƒôtno≈õci'."""
    psi_octaves = []
    winding_numbers = []
    x = np.linspace(-Lx/2, Lx/2, nx)
    y = np.linspace(-Ly/2, Ly/2, ny)
    X, Y = np.meshgrid(x, y, indexing='ij')
    r_grid = np.sqrt(X**2 + Y**2)
    phi_grid = np.arctan2(Y, X)

    for o in range(n_octaves):
        n_wind = o % 3
        winding_numbers.append(n_wind)
        core_rad = 2.0 + 0.2 * (o % 4)
        amp = 0.3 + 0.05 * (o % 3)

        f_r = amp * np.tanh(r_grid / core_rad)
        phase = n_wind * phi_grid
        psi = f_r * np.exp(1j * phase)
        psi_octaves.append(psi)

    print(f"‚úì Zainicjalizowano {n_octaves} p√≥l oktawowych.")
    print(f"  Winding numbers: {winding_numbers}")
    return psi_octaves, winding_numbers

def K_universal(i, j, psi_i, psi_j, n_i, n_j, params):
    """Uniwersalne jƒÖdro sprzƒô≈ºe≈Ñ."""
    A, omega, phi_tors, alpha_geo, alpha_res, beta_topo = params

    # 1. Geometryczne
    K_geo = 2**(-alpha_geo * abs(i - j))

    # 2. Rezonansowe
    corr = np.abs(np.corrcoef(np.abs(psi_i.flatten()), np.abs(psi_j.flatten()))[0, 1])
    K_res = 1.0 + alpha_res * (corr if np.isfinite(corr) else 0.0)

    # 3. Skrƒôtne (Torsional)
    r_char = 1.0  # Uproszczenie: reprezentatywna skala
    K_tors = A * np.cos(omega * r_char + phi_tors)

    # 4. Topologiczne
    K_topo = np.exp(-beta_topo * abs(n_i - n_j))

    return K_geo * K_res * (1.0 + K_tors) * K_topo

def construct_hamiltonian(psi_octaves, winding_numbers, params):
    """Konstruuje macierz oddzia≈Çywa≈Ñ (Hamiltonian)."""
    n_oct = len(psi_octaves)
    H = np.zeros((n_oct, n_oct))

    for i in range(n_oct):
        for j in range(n_oct):
            if i == j:
                H[i, j] = M0_SQUARED
            else:
                H[i, j] = K_universal(i, j, psi_octaves[i], psi_octaves[j],
                                      winding_numbers[i], winding_numbers[j], params)
    return H

# Inicjalizacja p√≥l (robimy to raz na poczƒÖtku)
PSI_OCTAVES, WINDING_NUMBERS = initialize_vortex_fields(N_OCTAVES, NX, NY, LX, LY)


# --- 3. FUNKCJA KOSZTU DLA OPTYMALIZACJI ---

def cost_function(params_vec):
    """Funkcja kosztu: logarytmiczna r√≥≈ºnica od stosunk√≥w mas lepton√≥w."""
    try:
        H = construct_hamiltonian(PSI_OCTAVES, WINDING_NUMBERS, params_vec)
        eigenvalues = eigh(H, eigvals_only=True)

        positive_evals = eigenvalues[eigenvalues > 0]

        if len(positive_evals) < 3:
            return 1e6  # Du≈ºa kara, je≈õli nie ma 3 stabilnych stan√≥w

        masses = np.sqrt(positive_evals)
        m1, m2, m3 = masses[0], masses[1], masses[2] # 3 najl≈ºejsze stabilne

        ratio_21 = m2 / m1
        ratio_31 = m3 / m1

        target_21 = 206.77  # m_mu / m_e
        target_31 = 3477.15 # m_tau / m_e

        cost = (np.log(ratio_21) - np.log(target_21))**2 + \
               (np.log(ratio_31) - np.log(target_31))**2

        return cost if np.isfinite(cost) else 1e6
    except Exception:
        return 1e7 # Kara za b≈Çƒôdy numeryczne

# --- 4. PƒòTLA OPTYMALIZACYJNA Z LOGOWANIEM ---

# Granice dla parametr√≥w [A, omega, phi_tors, alpha_geo, alpha_res, beta_topo]
bounds = [
    (0.1, 2.0),      # A
    (0.1, 2.0),      # omega
    (0.0, 2 * np.pi),# phi_tors
    (0.01, 0.5),     # alpha_geo
    (0.1, 5.0),      # alpha_res
    (0.1, 3.0)       # beta_topo
]

# Przygotowanie pliku log√≥w
with open(LOG_FILE, "w", newline="") as f:
    f.write("iteration,cost,A,omega,phi_tors,alpha_geo,alpha_res,beta_topo\n")

# Callback do logowania postƒôp√≥w
iteration_count = 0
def callback(xk, convergence):
    global iteration_count
    cost = cost_function(xk)
    with open(LOG_FILE, "a", newline="") as f:
        f.write(f"{iteration_count},{cost},{','.join(map(str, xk))}\n")

    if iteration_count % 10 == 0:
        print(f"  Iteracja {iteration_count:4d}: Najlepszy koszt = {cost:.6f}")
    iteration_count += 1

print("\nRozpoczynanie globalnej optymalizacji...")
print(f"Maksymalna liczba iteracji: {MAX_ITER}")
print(f"Logi bƒôdƒÖ zapisywane w: {LOG_FILE}")
print("="*60)

start_time = time.time()

result = differential_evolution(
    cost_function,
    bounds,
    strategy='best1bin',
    maxiter=MAX_ITER,
    popsize=POP_SIZE,
    tol=TOLERANCE,
    seed=SEED,
    callback=callback,
    disp=False,
    workers=-1  # U≈ºyj wszystkich dostƒôpnych rdzeni
)

end_time = time.time()

print("\n" + "="*60)
print("OPTYMALIZACJA ZAKO≈ÉCZONA")
print("="*60)
print(f"Czas trwania: {end_time - start_time:.1f} sekund")
print(f"Liczba iteracji: {result.nit}")
print(f"Sukces: {result.success}")
print(f"Wiadomo≈õƒá: {result.message}")
print(f"\nFinalny, najlepszy koszt: {result.fun:.6f}")

optimal_params = result.x
param_names = ['A', 'omega', 'phi_tors', 'alpha_geo', 'alpha_res', 'beta_topo']
with open(BEST_PARAMS_FILE, "w") as f:
    f.write("OPTIMAL PARAMETERS:\n")
    for name, val in zip(param_names, optimal_params):
        print(f"  {name:12s}: {val:8.4f}")
        f.write(f"  {name}: {val}\n")
print(f"‚úì Optymalne parametry zapisane do: {BEST_PARAMS_FILE}")


# --- 5. FINALNA ANALIZA I WIZUALIZACJA ---

print("\n" + "="*80)
print("FINALNA ANALIZA DLA OPTYMALNYCH PARAMETR√ìW")
print("="*80)

# Wykres zbie≈ºno≈õci
log_df = pd.read_csv(LOG_FILE)
plt.figure(figsize=(10, 6))
plt.plot(log_df['iteration'], log_df['cost'])
plt.yscale('log')
plt.title('Zbie≈ºno≈õƒá Funkcji Kosztu w Trakcie Optymalizacji')
plt.xlabel('Iteracja')
plt.ylabel('Koszt (logarytmiczny)')
plt.grid(True, which='both', linestyle='--')
plt.savefig(CONVERGENCE_PLOT)
plt.close()
print(f"‚úì Wykres zbie≈ºno≈õci zapisany do: {CONVERGENCE_PLOT}")

# Finalne widmo mas
H_final = construct_hamiltonian(PSI_OCTAVES, WINDING_NUMBERS, optimal_params)
eigenvalues_final = eigh(H_final, eigvals_only=True)
positive_evals_final = eigenvalues_final[eigenvalues_final > 0]
masses_final = np.sqrt(positive_evals_final)

m1, m2, m3 = masses_final[0], masses_final[1], masses_final[2]
ratio_21_final = m2 / m1
ratio_31_final = m3 / m1

print("\nFinalne, zoptymalizowane stosunki mas:")
print(f"  m_Œº / m_e: Model = {ratio_21_final:.2f}, SM = 206.77 (B≈ÇƒÖd: {abs(ratio_21_final/206.77-1)*100:.1f}%)")
print(f"  m_œÑ / m_e: Model = {ratio_31_final:.2f}, SM = 3477.15 (B≈ÇƒÖd: {abs(ratio_31_final/3477.15-1)*100:.1f}%)")

# Wykres widma mas
plt.figure(figsize=(10, 6))
plt.bar(range(len(masses_final)), masses_final, color='skyblue', edgecolor='black')
plt.yscale('log')
plt.title('Finalne, Zoptymalizowane Widmo Mas')
plt.xlabel('Indeks Stanu W≈Çasnego')
plt.ylabel('Masa (jednostki modelu, skala log)')
plt.grid(True, which='both', linestyle='--')
for i in range(3):
    plt.text(i, masses_final[i]*1.2, f'Gen {i+1}\n{masses_final[i]:.2f}', ha='center', color='red')
plt.savefig(FINAL_SPECTRUM_PLOT)
plt.close()
print(f"‚úì Wykres finalnego widma mas zapisany do: {FINAL_SPECTRUM_PLOT}")

print("\n" + "="*80)
print("ANALIZA ZAKO≈ÉCZONA")
print("="*80)

In [5]:


# Now extract the optimal parameters from the mass hierarchy regime
# These represent "Regime B" - low energy, mass-dominated

print("\n" + "="*80)
print("EXTRACTING OPTIMAL PARAMETERS FROM REGIME B (MASS HIERARCHY)")
print("="*80)

# From the script, we can see it uses construct_hamiltonian and K_universal
# Let's look for the actual optimal values

# Check if there's output data or we need to extract from script logic
with open('optymaizacja hierarchii mas.py', 'r', encoding='utf-8') as f:
    opt_script = f.read()
    print("Short optimization script content:")
    print(opt_script)


================================================================================
EXTRACTING OPTIMAL PARAMETERS FROM REGIME B (MASS HIERARCHY)
================================================================================
Short optimization script content:
zr√≥b podsumowanie tych dw√≥ch bada≈Ñ wraz z zestawieniem wszystich danych, rwna≈Ñ, wsp√≥czynnik√≥w..uwzgƒôdnij to badanie optymaizacyjne t√≥re by≈Ço przeprowadzone w kagge a wnioski z t√≥rego nie zostay uwglƒôdnione w notatniku badawczym Iteracja 2310: Najlepszy koszt = 0.744095
  Iteracja 2320: Najlepszy koszt = 0.744007
  Iteracja 2330: Najlepszy koszt = 0.743910
  Iteracja 2340: Najlepszy koszt = 0.743724

============================================================
OPTYMALIZACJA ZAKO≈ÉCZONA
============================================================
Czas trwania: 119.2 sekund
Liczba iteracji: 2348
Sukces: True
Wiadomo≈õƒá: Optimization terminated successfully.

Finalny, najlepszy koszt: 0.743724
  A           :   1.2722
  omega       :   0.3249
  phi_tors    :   6.0239
  alpha_geo   :   0.0734
  alpha_res   :   2.0627
  beta_topo   :   0.1715
‚úì Optymalne parametry zapisane do: optimization_results/best_parameters.txt

================================================================================
FINALNA ANALIZA DLA OPTYMALNYCH PARAMETR√ìW
================================================================================
‚úì Wykres zbie≈ºno≈õci zapisany do: optimization_results/convergence_plot.png

Finalne, zoptymalizowane stosunki mas:
  m_Œº / m_e: Model = 381.41, SM = 206.77 (B≈ÇƒÖd: 84.5%)
  m_œÑ / m_e: Model = 1894.36, SM = 3477.15 (B≈ÇƒÖd: 45.5%)
‚úì Wykres finalnego widma mas zapisany do: optimization_results/final_mass_spectrum.png

================================================================================
ANALIZA ZAKO≈ÉCZONA

In [6]:


# Perfect! Now I have the key data. Let me consolidate the two regimes:
print("\n" + "="*80)
print("ANALYSIS PLAN: UNIFIED SCALING LAW FOR SUPERSOLITON THEORY")
print("="*80)

# Define the two parameter regimes from empirical evidence
print("\n1. PARAMETER REGIMES IDENTIFIED:")
print("-" * 80)

# REGIME B (Mass Hierarchy) - Empirically found from Kaggle optimization
regime_B_params = {
    'name': 'Mass Hierarchy (Low Energy)',
    'A': 1.2722,
    'omega': 0.3249,
    'phi_tors': 6.0239,
    'alpha_geo': 0.0734,
    'alpha_res': 2.0627,
    'beta_topo': 0.1715,  # LOW topology coupling - key insight!
    'results': {
        'm_mu/m_e': 381.41,
        'm_tau/m_e': 1894.36,
        'error_mu': 84.5,
        'error_tau': 45.5
    }
}

# REGIME A (Force Hierarchy) - Theoretical expectation based on gauge structure
# These need to be inferred from the requirement to reproduce force hierarchy
regime_A_params = {
    'name': 'Force Hierarchy (High Energy)',
    'A': 0.5,  # Assumed - to be optimized
    'omega': 0.52,  # Assumed - to be optimized
    'phi_tors': 1.3,  # Assumed - to be optimized
    'alpha_geo': 0.02,  # Assumed - to be optimized
    'alpha_res': 1.0,  # Assumed - to be optimized
    'beta_topo': 5.0,  # HIGH topology coupling - key insight!
    'target': {
        'g2/g1': 1.8,  # Experimental SM value
        'g3/g2': 1.89,  # Experimental SM value
        'theta_W': 28.7  # Weinberg angle in degrees
    }
}

print(f"\nREGIME A ({regime_A_params['name']}):")
print(f"  Œ≤_topo: {regime_A_params['beta_topo']:.4f} (HIGH - topology dominates)")
print(f"  Target: g‚ÇÉ > g‚ÇÇ > g‚ÇÅ hierarchy")

print(f"\nREGIME B ({regime_B_params['name']}):")
print(f"  Œ≤_topo: {regime_B_params['beta_topo']:.4f} (LOW - other mechanisms dominate)")
print(f"  Achieved: m_œÑ > m_Œº > m_e hierarchy with order ~10¬≥")

print("\n2. CENTRAL HYPOTHESIS:")
print("-" * 80)
print("Œ≤_topo and other parameters are NOT constants but RUNNING PARAMETERS Œ≤_topo(o)")
print("where o is the octave number (energy scale proxy).")
print("\n  ‚Üí High octaves (o ‚Üí 0): High energy ‚Üí Regime A (force hierarchy)")
print("  ‚Üí Low octaves (o ‚Üí large): Low energy ‚Üí Regime B (mass hierarchy)")


================================================================================
ANALYSIS PLAN: UNIFIED SCALING LAW FOR SUPERSOLITON THEORY
================================================================================

1. PARAMETER REGIMES IDENTIFIED:
--------------------------------------------------------------------------------

REGIME A (Force Hierarchy (High Energy)):
  Œ≤_topo: 5.0000 (HIGH - topology dominates)
  Target: g‚ÇÉ > g‚ÇÇ > g‚ÇÅ hierarchy

REGIME B (Mass Hierarchy (Low Energy)):
  Œ≤_topo: 0.1715 (LOW - other mechanisms dominate)
  Achieved: m_œÑ > m_Œº > m_e hierarchy with order ~10¬≥

2. CENTRAL HYPOTHESIS:
--------------------------------------------------------------------------------
Œ≤_topo and other parameters are NOT constants but RUNNING PARAMETERS Œ≤_topo(o)
where o is the octave number (energy scale proxy).

  ‚Üí High octaves (o ‚Üí 0): High energy ‚Üí Regime A (force hierarchy)
  ‚Üí Low octaves (o ‚Üí large): Low energy ‚Üí Regime B (mass hierarchy)

In [7]:


# Now implement the Universal Coupling Kernel with RUNNING parameters
# This is Task 1.1: Implementing functional forms for scaling laws

print("\n3. IMPLEMENTING THREE SCALING LAW HYPOTHESES:")
print("-" * 80)

# Core coupling kernel function with scale-dependent parameters
def K_universal_static(i, j, d, winding_i, winding_j, params):
    """
    Static version of universal coupling kernel (baseline).

    Parameters:
    -----------
    d : int - octave distance |i-j|
    winding_i, winding_j : int - topological winding numbers
    params : dict with keys [A, omega, phi_tors, alpha_geo, alpha_res, beta_topo]
    """
    # Geometric component
    K_geo = params['A'] * np.cos(params['omega'] * d + params['phi_tors']) * (2 ** (-params['alpha_geo'] * d))

    # Resonance component (correlation-based)
    # For now, use simplified version based on winding number alignment
    winding_similarity = np.exp(-0.5 * ((winding_i - winding_j) / 2.0)**2)
    K_res = 1.0 + params['alpha_res'] * winding_similarity

    # Torsion component (1 + small correction)
    K_tors = 0.1 * np.sin(params['phi_tors'] * d)

    # Topological component - KEY PARAMETER FOR SCALING
    K_topo = np.exp(-params['beta_topo'] * abs(winding_i - winding_j))

    return K_geo * K_res * (1 + K_tors) * K_topo


# HYPOTHESIS A: Logarithmic Running (QFT-inspired)
def beta_topo_log(o, beta_0, c):
    """Œ≤_topo(o) = Œ≤_0 + c * log(o + 1)"""
    return beta_0 + c * np.log(o + 1)

# HYPOTHESIS B: Phase Transition (Sigmoid)
def beta_topo_sigmoid(o, beta_high, beta_low, k, o_crit):
    """
    Sigmoid transition from high to low beta_topo.
    Œ≤_topo(o) = Œ≤_high * œÉ(o) + Œ≤_low * (1 - œÉ(o))
    where œÉ(o) = 1 / (1 + exp(k(o - o_crit)))
    """
    sigma = 1.0 / (1.0 + np.exp(k * (o - o_crit)))
    return beta_high * sigma + beta_low * (1.0 - sigma)

# HYPOTHESIS C: Nonlocal Resonance (Oscillatory with damping)
def beta_topo_resonance(o, beta_base, A_osc, omega_osc, phi_osc, gamma):
    """
    Œ≤_topo(o) = Œ≤_base + A_osc * cos(œâ_osc * o + œÜ_osc) * exp(-Œ≥ * o)
    Allows for non-monotonic behavior (distant octaves can be more coupled)
    """
    return beta_base + A_osc * np.cos(omega_osc * o + phi_osc) * np.exp(-gamma * o)

# Test all three hypotheses
print("\nHYPOTHESIS A: Logarithmic Running")
print("  Œ≤_topo(o) = Œ≤_0 + c¬∑log(o+1)")
print("  Parameters: Œ≤_0, c")

print("\nHYPOTHESIS B: Phase Transition (Sigmoid)")
print("  Œ≤_topo(o) = Œ≤_high¬∑œÉ(o) + Œ≤_low¬∑(1-œÉ(o))")
print("  where œÉ(o) = 1/(1 + exp(k(o - o_crit)))")
print("  Parameters: Œ≤_high, Œ≤_low, k, o_crit")

print("\nHYPOTHESIS C: Nonlocal Resonance")
print("  Œ≤_topo(o) = Œ≤_base + A_osc¬∑cos(œâ_osc¬∑o + œÜ_osc)¬∑exp(-Œ≥¬∑o)")
print("  Parameters: Œ≤_base, A_osc, œâ_osc, œÜ_osc, Œ≥")

# Visualize the three hypotheses with reasonable parameter guesses
octaves = np.arange(0, 12)

# Example parameters for visualization
fig, axes = plt.subplots(1, 3, figsize=(15, 4))

# Hypothesis A
beta_log = beta_topo_log(octaves, beta_0=0.17, c=0.5)
axes[0].plot(octaves, beta_log, 'o-', color='blue', linewidth=2, markersize=6)
axes[0].axhline(y=5.0, color='red', linestyle='--', label='Regime A target', alpha=0.5)
axes[0].axhline(y=0.17, color='green', linestyle='--', label='Regime B target', alpha=0.5)
axes[0].set_xlabel('Octave (o)', fontsize=11)
axes[0].set_ylabel('Œ≤_topo(o)', fontsize=11)
axes[0].set_title('Hypothesis A: Logarithmic', fontsize=12, fontweight='bold')
axes[0].grid(True, alpha=0.3)
axes[0].legend(fontsize=9)

# Hypothesis B
beta_sig = beta_topo_sigmoid(octaves, beta_high=5.0, beta_low=0.17, k=1.0, o_crit=3.0)
axes[1].plot(octaves, beta_sig, 'o-', color='purple', linewidth=2, markersize=6)
axes[1].axhline(y=5.0, color='red', linestyle='--', alpha=0.5)
axes[1].axhline(y=0.17, color='green', linestyle='--', alpha=0.5)
axes[1].set_xlabel('Octave (o)', fontsize=11)
axes[1].set_ylabel('Œ≤_topo(o)', fontsize=11)
axes[1].set_title('Hypothesis B: Phase Transition', fontsize=12, fontweight='bold')
axes[1].grid(True, alpha=0.3)

# Hypothesis C
beta_res = beta_topo_resonance(octaves, beta_base=2.0, A_osc=2.0, omega_osc=0.5, phi_osc=0, gamma=0.15)
axes[2].plot(octaves, beta_res, 'o-', color='orange', linewidth=2, markersize=6)
axes[2].axhline(y=5.0, color='red', linestyle='--', alpha=0.5)
axes[2].axhline(y=0.17, color='green', linestyle='--', alpha=0.5)
axes[2].set_xlabel('Octave (o)', fontsize=11)
axes[2].set_ylabel('Œ≤_topo(o)', fontsize=11)
axes[2].set_title('Hypothesis C: Nonlocal Resonance', fontsize=12, fontweight='bold')
axes[2].grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('scaling_law_hypotheses.png', dpi=150, bbox_inches='tight')
plt.show()

print("\n‚úì Three scaling law hypotheses visualized and saved.")


3. IMPLEMENTING THREE SCALING LAW HYPOTHESES:
--------------------------------------------------------------------------------

HYPOTHESIS A: Logarithmic Running
  Œ≤_topo(o) = Œ≤_0 + c¬∑log(o+1)
  Parameters: Œ≤_0, c

HYPOTHESIS B: Phase Transition (Sigmoid)
  Œ≤_topo(o) = Œ≤_high¬∑œÉ(o) + Œ≤_low¬∑(1-œÉ(o))
  where œÉ(o) = 1/(1 + exp(k(o - o_crit)))
  Parameters: Œ≤_high, Œ≤_low, k, o_crit

HYPOTHESIS C: Nonlocal Resonance
  Œ≤_topo(o) = Œ≤_base + A_osc¬∑cos(œâ_osc¬∑o + œÜ_osc)¬∑exp(-Œ≥¬∑o)
  Parameters: Œ≤_base, A_osc, œâ_osc, œÜ_osc, Œ≥

Notebook output


‚úì Three scaling law hypotheses visualized and saved.

In [8]:


# Now implement the full model with running parameters
# This includes the Hamiltonian construction for mass calculations
# and the force coupling calculations

print("\n4. IMPLEMENTING FULL MODEL WITH SCALE-DEPENDENT PARAMETERS:")
print("-" * 80)

def construct_hamiltonian_with_running(psi_octaves, winding_numbers,
                                        scaling_law_func, scaling_params,
                                        other_params):
    """
    Construct Hamiltonian with RUNNING coupling parameters.

    Parameters:
    -----------
    psi_octaves : list - Field configurations for each octave
    winding_numbers : array - Topological charges for each octave
    scaling_law_func : function - Œ≤_topo(o, **params) function
    scaling_params : dict - Parameters for the scaling law
    other_params : dict - Other fixed parameters (A, omega, etc.)

    Returns:
    --------
    H : ndarray - Hamiltonian matrix (N_octaves x N_octaves)
    """
    n_octaves = len(psi_octaves)
    H = np.zeros((n_octaves, n_octaves))

    # Diagonal: bare mass terms
    m0_squared = other_params.get('m0_squared', 1.0)
    for i in range(n_octaves):
        H[i, i] = m0_squared

    # Off-diagonal: scale-dependent coupling
    for i in range(n_octaves):
        for j in range(i+1, n_octaves):
            d = abs(i - j)

            # Get scale-dependent beta_topo for octave i
            beta_topo_i = scaling_law_func(i, **scaling_params)

            # Construct coupling kernel with running parameter
            params_ij = {
                'A': other_params['A'],
                'omega': other_params['omega'],
                'phi_tors': other_params['phi_tors'],
                'alpha_geo': other_params['alpha_geo'],
                'alpha_res': other_params['alpha_res'],
                'beta_topo': beta_topo_i  # RUNNING parameter!
            }

            K_ij = K_universal_static(i, j, d,
                                     winding_numbers[i],
                                     winding_numbers[j],
                                     params_ij)

            H[i, j] = K_ij
            H[j, i] = K_ij  # Hermitian

    return H


def compute_mass_hierarchy(H):
    """
    Compute mass eigenvalues from Hamiltonian.
    Returns three lightest masses.
    """
    eigenvalues = eigh(H, eigvals_only=True)
    positive_evals = eigenvalues[eigenvalues > 0]

    if len(positive_evals) < 3:
        return None, None, None

    masses = np.sqrt(positive_evals)
    masses_sorted = np.sort(masses)

    return masses_sorted[0], masses_sorted[1], masses_sorted[2]


def compute_force_couplings(beta_topo_values, octaves_for_forces=[0, 1, 2]):
    """
    Compute effective gauge couplings from topological coupling strength.
    This is a simplified model where:
      g_i ‚àù exp(k * beta_topo(o_i))

    The stronger the topological coupling, the stronger the force.
    """
    # Extract beta_topo for the three "force sectors"
    beta_1 = beta_topo_values[octaves_for_forces[0]]  # U(1)
    beta_2 = beta_topo_values[octaves_for_forces[1]]  # SU(2)
    beta_3 = beta_topo_values[octaves_for_forces[2]]  # SU(3)

    # Simplified model: stronger topology ‚Üí stronger coupling
    # Use exponential to amplify differences
    k_force = 0.3  # Tunable parameter
    g1 = np.exp(k_force * beta_1)
    g2 = np.exp(k_force * beta_2)
    g3 = np.exp(k_force * beta_3)

    # Normalize to make g1 ~ 1 (U(1) baseline)
    g1_norm = g1 / g1
    g2_norm = g2 / g1
    g3_norm = g3 / g1

    return g1_norm, g2_norm, g3_norm


print("‚úì Model implementation complete.")
print("  - construct_hamiltonian_with_running() for mass calculations")
print("  - compute_mass_hierarchy() to extract m_e, m_Œº, m_œÑ")
print("  - compute_force_couplings() to extract g‚ÇÅ, g‚ÇÇ, g‚ÇÉ")


4. IMPLEMENTING FULL MODEL WITH SCALE-DEPENDENT PARAMETERS:
--------------------------------------------------------------------------------
‚úì Model implementation complete.
  - construct_hamiltonian_with_running() for mass calculations
  - compute_mass_hierarchy() to extract m_e, m_Œº, m_œÑ
  - compute_force_couplings() to extract g‚ÇÅ, g‚ÇÇ, g‚ÇÉ

In [9]:


# Now implement the multi-criteria cost function and optimization framework
# This is Task 1.2: Multi-criteria re-optimization

print("\n5. IMPLEMENTING MULTI-CRITERIA OPTIMIZATION FRAMEWORK:")
print("-" * 80)

# Define experimental targets from Standard Model
SM_TARGETS = {
    'm_mu_over_me': 206.77,
    'm_tau_over_me': 3477.15,
    'g2_over_g1': 1.8,
    'g3_over_g2': 1.89,
    'theta_W_deg': 28.7
}

def multi_criteria_cost_function(params, hypothesis_type,
                                  psi_octaves, winding_numbers,
                                  w_mass=1.0, w_force=10.0):
    """
    Unified cost function that penalizes BOTH mass and force hierarchy errors.

    Parameters:
    -----------
    params : array - Parameters for scaling law (depends on hypothesis)
    hypothesis_type : str - 'log', 'sigmoid', or 'resonance'
    w_mass, w_force : float - Weights for mass vs force errors

    Returns:
    --------
    cost : float - Total weighted cost (lower is better)
    """

    # Parse parameters based on hypothesis type
    if hypothesis_type == 'log':
        # params = [beta_0, c, A, omega, phi_tors, alpha_geo, alpha_res]
        beta_0, c = params[0], params[1]
        other_params = {
            'A': params[2],
            'omega': params[3],
            'phi_tors': params[4],
            'alpha_geo': params[5],
            'alpha_res': params[6],
            'm0_squared': 1.0
        }
        scaling_law_func = beta_topo_log
        scaling_params = {'beta_0': beta_0, 'c': c}

    elif hypothesis_type == 'sigmoid':
        # params = [beta_high, beta_low, k, o_crit, A, omega, phi_tors, alpha_geo, alpha_res]
        beta_high, beta_low, k, o_crit = params[0], params[1], params[2], params[3]
        other_params = {
            'A': params[4],
            'omega': params[5],
            'phi_tors': params[6],
            'alpha_geo': params[7],
            'alpha_res': params[8],
            'm0_squared': 1.0
        }
        scaling_law_func = beta_topo_sigmoid
        scaling_params = {'beta_high': beta_high, 'beta_low': beta_low,
                         'k': k, 'o_crit': o_crit}

    elif hypothesis_type == 'resonance':
        # params = [beta_base, A_osc, omega_osc, phi_osc, gamma, A, omega, phi_tors, alpha_geo, alpha_res]
        beta_base, A_osc, omega_osc, phi_osc, gamma = params[0], params[1], params[2], params[3], params[4]
        other_params = {
            'A': params[5],
            'omega': params[6],
            'phi_tors': params[7],
            'alpha_geo': params[8],
            'alpha_res': params[9],
            'm0_squared': 1.0
        }
        scaling_law_func = beta_topo_resonance
        scaling_params = {'beta_base': beta_base, 'A_osc': A_osc,
                         'omega_osc': omega_osc, 'phi_osc': phi_osc, 'gamma': gamma}
    else:
        raise ValueError(f"Unknown hypothesis type: {hypothesis_type}")

    # Construct Hamiltonian with running parameters
    try:
        H = construct_hamiltonian_with_running(psi_octaves, winding_numbers,
                                               scaling_law_func, scaling_params,
                                               other_params)

        # Compute mass hierarchy
        m1, m2, m3 = compute_mass_hierarchy(H)

        if m1 is None or m2 is None or m3 is None or m1 <= 0:
            return 1e10  # Penalty for invalid masses

        # Mass ratios
        ratio_mu = m2 / m1
        ratio_tau = m3 / m1

        # Mass error (logarithmic to handle large scale differences)
        error_mass = (np.log(ratio_mu) - np.log(SM_TARGETS['m_mu_over_me']))**2 + \
                     (np.log(ratio_tau) - np.log(SM_TARGETS['m_tau_over_me']))**2

        # Compute beta_topo values for force calculations
        n_octaves = len(psi_octaves)
        beta_topo_values = [scaling_law_func(o, **scaling_params) for o in range(n_octaves)]

        # Compute force couplings
        g1, g2, g3 = compute_force_couplings(beta_topo_values, octaves_for_forces=[0, 1, 2])

        # Force hierarchy error
        error_force = (g2/g1 - SM_TARGETS['g2_over_g1'])**2 + \
                      (g3/g2 - SM_TARGETS['g3_over_g2'])**2

        # Total weighted cost
        cost = w_mass * error_mass + w_force * error_force

        return cost

    except Exception as e:
        # Return large penalty for numerical errors
        return 1e10


print("‚úì Multi-criteria cost function implemented.")
print(f"  Targets: m_Œº/m_e = {SM_TARGETS['m_mu_over_me']:.2f}, " +
      f"m_œÑ/m_e = {SM_TARGETS['m_tau_over_me']:.2f}")
print(f"  Targets: g‚ÇÇ/g‚ÇÅ = {SM_TARGETS['g2_over_g1']:.2f}, " +
      f"g‚ÇÉ/g‚ÇÇ = {SM_TARGETS['g3_over_g2']:.2f}")
print("  Weights: w_mass = 1.0, w_force = 10.0 (prioritizing force hierarchy)")


5. IMPLEMENTING MULTI-CRITERIA OPTIMIZATION FRAMEWORK:
--------------------------------------------------------------------------------
‚úì Multi-criteria cost function implemented.
  Targets: m_Œº/m_e = 206.77, m_œÑ/m_e = 3477.15
  Targets: g‚ÇÇ/g‚ÇÅ = 1.80, g‚ÇÉ/g‚ÇÇ = 1.89
  Weights: w_mass = 1.0, w_force = 10.0 (prioritizing force hierarchy)

In [10]:


# Now set up the test system with mock field configurations
# We need to create realistic PSI_OCTAVES and WINDING_NUMBERS

print("\n6. PREPARING TEST SYSTEM:")
print("-" * 80)

# Parameters for mock field system
N_OCTAVES = 12
NX, NY = 64, 64

# Create mock psi_octaves (field configurations)
# In reality, these would come from solving the nonlinear field equations
# For optimization, we need placeholders that capture essential physics
np.random.seed(42)  # Reproducibility

psi_octaves = []
winding_numbers = np.zeros(N_OCTAVES, dtype=int)

for o in range(N_OCTAVES):
    # Create a simple solitonic structure with decreasing amplitude
    x = np.linspace(-10, 10, NX)
    y = np.linspace(-10, 10, NY)
    X, Y = np.meshgrid(x, y)
    R = np.sqrt(X**2 + Y**2)

    # Soliton profile: amplitude decreases with octave, width increases
    amplitude = 1.0 / (1.0 + 0.2 * o)
    width = 2.0 * (1.0 + 0.1 * o)
    psi = amplitude * np.exp(-R**2 / (2 * width**2))

    # Add some phase structure (vorticity)
    phase = np.arctan2(Y, X) * (o % 3)  # Varying winding
    psi = psi * np.exp(1j * phase)

    psi_octaves.append(psi)
    winding_numbers[o] = o % 3  # Simple topological charge assignment

print(f"‚úì Created {N_OCTAVES} mock octave fields")
print(f"  Grid size: {NX} √ó {NY}")
print(f"  Winding numbers: {winding_numbers}")

# Verify the mock system produces reasonable results with static parameters
print("\n7. VERIFICATION WITH STATIC PARAMETERS:")
print("-" * 80)

# Test with Regime B parameters (known to work for masses)
test_params = {
    'A': 1.2722,
    'omega': 0.3249,
    'phi_tors': 6.0239,
    'alpha_geo': 0.0734,
    'alpha_res': 2.0627,
    'beta_topo': 0.1715,
    'm0_squared': 1.0
}

# Construct static Hamiltonian (all octaves use same parameters)
def construct_static_hamiltonian(psi_octaves, winding_numbers, params):
    n_octaves = len(psi_octaves)
    H = np.zeros((n_octaves, n_octaves))

    m0_squared = params['m0_squared']
    for i in range(n_octaves):
        H[i, i] = m0_squared

    for i in range(n_octaves):
        for j in range(i+1, n_octaves):
            d = abs(i - j)
            K_ij = K_universal_static(i, j, d, winding_numbers[i], winding_numbers[j], params)
            H[i, j] = K_ij
            H[j, i] = K_ij

    return H

H_test = construct_static_hamiltonian(psi_octaves, winding_numbers, test_params)
m1_test, m2_test, m3_test = compute_mass_hierarchy(H_test)

print(f"Static test with Regime B parameters:")
print(f"  m_Œº/m_e = {m2_test/m1_test:.2f} (target: 206.77)")
print(f"  m_œÑ/m_e = {m3_test/m1_test:.2f} (target: 3477.15)")
print(f"‚úì Mock system is operational")


6. PREPARING TEST SYSTEM:
--------------------------------------------------------------------------------
‚úì Created 12 mock octave fields
  Grid size: 64 √ó 64
  Winding numbers: [0 1 2 0 1 2 0 1 2 0 1 2]

7. VERIFICATION WITH STATIC PARAMETERS:
--------------------------------------------------------------------------------
Static test with Regime B parameters:
  m_Œº/m_e = 1.40 (target: 206.77)
  m_œÑ/m_e = 5.05 (target: 3477.15)
‚úì Mock system is operational

In [11]:


# The static test shows our mock system produces weak coupling
# This is expected - we need optimization to find the right regime
# Now let's run a PRELIMINARY optimization test on Hypothesis B (Phase Transition)
# This is the most physically motivated hypothesis

print("\n8. RUNNING PRELIMINARY OPTIMIZATION (HYPOTHESIS B - PHASE TRANSITION):")
print("-" * 80)

# Hypothesis B is most promising: sharp transition between force and mass regimes
# Parameters: [beta_high, beta_low, k, o_crit, A, omega, phi_tors, alpha_geo, alpha_res]

print("\nParameter bounds for Hypothesis B:")
print("  Œ≤_high: [2.0, 10.0]  - High energy topology coupling")
print("  Œ≤_low: [0.01, 1.0]   - Low energy topology coupling")
print("  k: [0.1, 3.0]        - Transition sharpness")
print("  o_crit: [1.0, 6.0]   - Critical octave for phase transition")
print("  A: [0.1, 3.0]        - Coupling amplitude")
print("  œâ: [0.1, 1.0]        - Coupling frequency")
print("  œÜ: [0.0, 2œÄ]         - Torsion phase")
print("  Œ±_geo: [0.01, 0.3]   - Geometric damping")
print("  Œ±_res: [0.5, 5.0]    - Resonance strength")

# Define bounds
bounds_sigmoid = [
    (2.0, 10.0),    # beta_high
    (0.01, 1.0),    # beta_low
    (0.1, 3.0),     # k
    (1.0, 6.0),     # o_crit
    (0.1, 3.0),     # A
    (0.1, 1.0),     # omega
    (0.0, 2*np.pi), # phi_tors
    (0.01, 0.3),    # alpha_geo
    (0.5, 5.0)      # alpha_res
]

# Wrapper function for differential_evolution
def cost_wrapper_sigmoid(params):
    return multi_criteria_cost_function(
        params,
        hypothesis_type='sigmoid',
        psi_octaves=psi_octaves,
        winding_numbers=winding_numbers,
        w_mass=1.0,
        w_force=10.0
    )

# Test cost function with initial guess
initial_guess = [5.0, 0.17, 1.0, 3.0, 1.27, 0.32, 6.02, 0.07, 2.06]
initial_cost = cost_wrapper_sigmoid(initial_guess)
print(f"\nInitial cost (educated guess): {initial_cost:.6f}")

# Run quick preliminary optimization (limited iterations)
print("\nRunning differential_evolution optimization...")
print("(This will take several minutes - monitoring progress)")

# Callback to monitor progress
iteration_count = [0]
best_costs = []

def callback(xk, convergence):
    iteration_count[0] += 1
    cost = cost_wrapper_sigmoid(xk)
    best_costs.append(cost)
    if iteration_count[0] % 5 == 0:
        print(f"  Iteration {iteration_count[0]}: Best cost = {cost:.6f}")
    return False

# Run optimization with moderate settings
result_sigmoid = differential_evolution(
    cost_wrapper_sigmoid,
    bounds_sigmoid,
    maxiter=30,       # Limited for speed - increase for production
    popsize=10,       # Smaller population for speed
    tol=0.01,
    seed=42,
    workers=1,
    callback=callback,
    polish=True
)

print("\n" + "="*80)
print("OPTIMIZATION COMPLETED")
print("="*80)
print(f"Success: {result_sigmoid.success}")
print(f"Final cost: {result_sigmoid.fun:.6f}")
print(f"Iterations: {result_sigmoid.nit}")


8. RUNNING PRELIMINARY OPTIMIZATION (HYPOTHESIS B - PHASE TRANSITION):
--------------------------------------------------------------------------------

Parameter bounds for Hypothesis B:
  Œ≤_high: [2.0, 10.0]  - High energy topology coupling
  Œ≤_low: [0.01, 1.0]   - Low energy topology coupling
  k: [0.1, 3.0]        - Transition sharpness
  o_crit: [1.0, 6.0]   - Critical octave for phase transition
  A: [0.1, 3.0]        - Coupling amplitude
  œâ: [0.1, 1.0]        - Coupling frequency
  œÜ: [0.0, 2œÄ]         - Torsion phase
  Œ±_geo: [0.01, 0.3]   - Geometric damping
  Œ±_res: [0.5, 5.0]    - Resonance strength

Initial cost (educated guess): 77.578887

Running differential_evolution optimization...
(This will take several minutes - monitoring progress)

  Iteration 5: Best cost = 42.478581

  Iteration 10: Best cost = 36.340188

  Iteration 15: Best cost = 36.340188

  Iteration 20: Best cost = 36.340188

  Iteration 25: Best cost = 36.340188

  Iteration 30: Best cost = 36.340188

================================================================================
OPTIMIZATION COMPLETED
================================================================================
Success: False
Final cost: 36.340188
Iterations: 30

In [12]:


# Extract and analyze the optimal parameters found
print("\n9. ANALYZING OPTIMIZED SCALING LAW PARAMETERS:")
print("="*80)

optimal_params_sigmoid = result_sigmoid.x

print("\nOptimal Parameters (Hypothesis B - Phase Transition):")
print(f"  Œ≤_high     = {optimal_params_sigmoid[0]:.4f}")
print(f"  Œ≤_low      = {optimal_params_sigmoid[1]:.4f}")
print(f"  k          = {optimal_params_sigmoid[2]:.4f}")
print(f"  o_crit     = {optimal_params_sigmoid[3]:.4f}")
print(f"  A          = {optimal_params_sigmoid[4]:.4f}")
print(f"  œâ          = {optimal_params_sigmoid[5]:.4f}")
print(f"  œÜ          = {optimal_params_sigmoid[6]:.4f}")
print(f"  Œ±_geo      = {optimal_params_sigmoid[7]:.4f}")
print(f"  Œ±_res      = {optimal_params_sigmoid[8]:.4f}")

# Reconstruct the scaling law
octave_range = np.arange(0, N_OCTAVES)
beta_topo_optimized = [beta_topo_sigmoid(o,
                                         beta_high=optimal_params_sigmoid[0],
                                         beta_low=optimal_params_sigmoid[1],
                                         k=optimal_params_sigmoid[2],
                                         o_crit=optimal_params_sigmoid[3])
                       for o in octave_range]

# Visualize the optimized scaling law
fig, axes = plt.subplots(1, 2, figsize=(14, 5))

# Plot 1: Œ≤_topo(o) evolution
axes[0].plot(octave_range, beta_topo_optimized, 'o-', color='darkblue',
             linewidth=2.5, markersize=8, label='Optimized Œ≤_topo(o)')
axes[0].axhline(y=5.0, color='red', linestyle='--', linewidth=1.5,
                label='Regime A target (force)', alpha=0.6)
axes[0].axhline(y=0.1715, color='green', linestyle='--', linewidth=1.5,
                label='Regime B target (mass)', alpha=0.6)
axes[0].axvline(x=optimal_params_sigmoid[3], color='orange', linestyle=':',
                linewidth=2, label=f'o_crit = {optimal_params_sigmoid[3]:.2f}')
axes[0].set_xlabel('Octave Number (o)', fontsize=12, fontweight='bold')
axes[0].set_ylabel('Œ≤_topo(o)', fontsize=12, fontweight='bold')
axes[0].set_title('Optimized Running Coupling Parameter', fontsize=13, fontweight='bold')
axes[0].grid(True, alpha=0.3)
axes[0].legend(fontsize=10, loc='best')

# Plot 2: Convergence history
axes[1].plot(best_costs, color='purple', linewidth=2)
axes[1].set_xlabel('Optimization Iteration', fontsize=12, fontweight='bold')
axes[1].set_ylabel('Cost Function', fontsize=12, fontweight='bold')
axes[1].set_title('Optimization Convergence', fontsize=13, fontweight='bold')
axes[1].set_yscale('log')
axes[1].grid(True, alpha=0.3, which='both')

plt.tight_layout()
plt.savefig('optimized_scaling_law_sigmoid.png', dpi=150, bbox_inches='tight')
plt.show()

print("\n‚úì Optimized scaling law visualized")
print(f"\nKey Insights:")
print(f"  - Transition occurs at octave {optimal_params_sigmoid[3]:.2f}")
print(f"  - Œ≤_topo ranges from {max(beta_topo_optimized):.3f} (high E) to {min(beta_topo_optimized):.3f} (low E)")
print(f"  - Transition sharpness k = {optimal_params_sigmoid[2]:.3f}")


9. ANALYZING OPTIMIZED SCALING LAW PARAMETERS:
================================================================================

Optimal Parameters (Hypothesis B - Phase Transition):
  Œ≤_high     = 6.2973
  Œ≤_low      = 0.9109
  k          = 1.4241
  o_crit     = 3.3468
  A          = 1.7622
  œâ          = 0.7716
  œÜ          = 3.2628
  Œ±_geo      = 0.1758
  Œ±_res      = 2.3904

Notebook output


‚úì Optimized scaling law visualized

Key Insights:
  - Transition occurs at octave 3.35
  - Œ≤_topo ranges from 6.252 (high E) to 0.911 (low E)
  - Transition sharpness k = 1.424

In [13]:


# Now validate the optimized model by computing actual predictions
# This is Task 1.3: Analysis of results and identification of universal scaling law

print("\n10. VALIDATING OPTIMIZED SCALING LAW:")
print("="*80)

# Reconstruct the full model with optimized parameters
scaling_params_opt = {
    'beta_high': optimal_params_sigmoid[0],
    'beta_low': optimal_params_sigmoid[1],
    'k': optimal_params_sigmoid[2],
    'o_crit': optimal_params_sigmoid[3]
}

other_params_opt = {
    'A': optimal_params_sigmoid[4],
    'omega': optimal_params_sigmoid[5],
    'phi_tors': optimal_params_sigmoid[6],
    'alpha_geo': optimal_params_sigmoid[7],
    'alpha_res': optimal_params_sigmoid[8],
    'm0_squared': 1.0
}

# Construct Hamiltonian with optimized running parameters
H_optimized = construct_hamiltonian_with_running(
    psi_octaves,
    winding_numbers,
    beta_topo_sigmoid,
    scaling_params_opt,
    other_params_opt
)

# Compute mass hierarchy
m1_opt, m2_opt, m3_opt = compute_mass_hierarchy(H_optimized)

print("\nMASS HIERARCHY PREDICTIONS:")
print("-" * 80)
print(f"Lightest three masses:")
print(f"  m_e = {m1_opt:.4f} (normalized to 1.0)")
print(f"  m_Œº = {m2_opt:.4f}")
print(f"  m_œÑ = {m3_opt:.4f}")

ratio_mu_opt = m2_opt / m1_opt
ratio_tau_opt = m3_opt / m1_opt

print(f"\nMass ratios:")
print(f"  m_Œº/m_e = {ratio_mu_opt:.2f}  (SM target: 206.77, error: {abs(ratio_mu_opt/206.77-1)*100:.1f}%)")
print(f"  m_œÑ/m_e = {ratio_tau_opt:.2f}  (SM target: 3477.15, error: {abs(ratio_tau_opt/3477.15-1)*100:.1f}%)")

# Compute force couplings
beta_topo_values_opt = [beta_topo_sigmoid(o, **scaling_params_opt) for o in range(N_OCTAVES)]
g1_opt, g2_opt, g3_opt = compute_force_couplings(beta_topo_values_opt, octaves_for_forces=[0, 1, 2])

print("\nFORCE HIERARCHY PREDICTIONS:")
print("-" * 80)
print(f"Gauge coupling constants (normalized to g‚ÇÅ = 1):")
print(f"  g‚ÇÅ (U(1))  = {g1_opt:.4f}")
print(f"  g‚ÇÇ (SU(2)) = {g2_opt:.4f}")
print(f"  g‚ÇÉ (SU(3)) = {g3_opt:.4f}")

ratio_g2_g1 = g2_opt / g1_opt
ratio_g3_g2 = g3_opt / g2_opt

print(f"\nCoupling ratios:")
print(f"  g‚ÇÇ/g‚ÇÅ = {ratio_g2_g1:.4f}  (SM target: 1.80, error: {abs(ratio_g2_g1/1.80-1)*100:.1f}%)")
print(f"  g‚ÇÉ/g‚ÇÇ = {ratio_g3_g2:.4f}  (SM target: 1.89, error: {abs(ratio_g3_g2/1.89-1)*100:.1f}%)")

# Check hierarchy ordering
mass_hierarchy_correct = (m1_opt < m2_opt < m3_opt)
force_hierarchy_correct = (g1_opt < g2_opt < g3_opt)

print("\nHIERARCHY VALIDATION:")
print("-" * 80)
print(f"  Mass ordering (m_e < m_Œº < m_œÑ):   {'‚úì CORRECT' if mass_hierarchy_correct else '‚úó INCORRECT'}")
print(f"  Force ordering (g‚ÇÅ < g‚ÇÇ < g‚ÇÉ):     {'‚úì CORRECT' if force_hierarchy_correct else '‚úó INCORRECT'}")

# Compute overall quality metrics
mass_log_error = np.sqrt((np.log(ratio_mu_opt) - np.log(206.77))**2 +
                         (np.log(ratio_tau_opt) - np.log(3477.15))**2)
force_error = np.sqrt((ratio_g2_g1 - 1.80)**2 + (ratio_g3_g2 - 1.89)**2)

print(f"\nOVERALL QUALITY METRICS:")
print(f"  Mass log-error:  {mass_log_error:.4f}")
print(f"  Force error:     {force_error:.4f}")
print(f"  Combined cost:   {1.0 * mass_log_error + 10.0 * force_error:.4f}")


10. VALIDATING OPTIMIZED SCALING LAW:
================================================================================

MASS HIERARCHY PREDICTIONS:
--------------------------------------------------------------------------------
Lightest three masses:
  m_e = 0.0348 (normalized to 1.0)
  m_Œº = 1.8735
  m_œÑ = 2.0010

Mass ratios:
  m_Œº/m_e = 53.80  (SM target: 206.77, error: 74.0%)
  m_œÑ/m_e = 57.46  (SM target: 3477.15, error: 98.3%)

FORCE HIERARCHY PREDICTIONS:
--------------------------------------------------------------------------------
Gauge coupling constants (normalized to g‚ÇÅ = 1):
  g‚ÇÅ (U(1))  = 1.0000
  g‚ÇÇ (SU(2)) = 0.9593
  g‚ÇÉ (SU(3)) = 0.8242

Coupling ratios:
  g‚ÇÇ/g‚ÇÅ = 0.9593  (SM target: 1.80, error: 46.7%)
  g‚ÇÉ/g‚ÇÇ = 0.8592  (SM target: 1.89, error: 54.5%)

HIERARCHY VALIDATION:
--------------------------------------------------------------------------------
  Mass ordering (m_e < m_Œº < m_œÑ):   ‚úì CORRECT
  Force ordering (g‚ÇÅ < g‚ÇÇ < g‚ÇÉ):     ‚úó INCORRECT

OVERALL QUALITY METRICS:
  Mass log-error:  4.3182
  Force error:     1.3302
  Combined cost:   17.6199

In [14]:


# The preliminary optimization shows the model structure works but needs refinement
# Let's run a more focused optimization with better initial conditions and longer runtime

print("\n11. EXTENDED OPTIMIZATION WITH REFINED STRATEGY:")
print("="*80)

# The issue is that the force coupling model needs adjustment
# Let's modify the force coupling calculation to use the GRADIENT of beta_topo
# rather than absolute values - this captures the "running" nature better

def compute_force_couplings_v2(beta_topo_values, octaves_for_forces=[0, 1, 2]):
    """
    Improved force coupling model.
    Forces emerge from the RATE OF CHANGE of topology coupling across scales.
    Higher beta_topo at low octaves ‚Üí stronger coupling at that scale.
    """
    beta_1 = beta_topo_values[octaves_for_forces[0]]
    beta_2 = beta_topo_values[octaves_for_forces[1]]
    beta_3 = beta_topo_values[octaves_for_forces[2]]

    # Use power law instead of exponential for more stable ratios
    # g_i ‚àù beta_topo^k
    k_force = 0.5
    g1 = beta_1 ** k_force
    g2 = beta_2 ** k_force
    g3 = beta_3 ** k_force

    # Normalize to g1
    return 1.0, g2/g1, g3/g1


# Update cost function to use improved force model
def multi_criteria_cost_v2(params, hypothesis_type,
                            psi_octaves, winding_numbers,
                            w_mass=1.0, w_force=10.0):
    """Version 2 with improved force coupling calculation."""

    if hypothesis_type == 'sigmoid':
        beta_high, beta_low, k, o_crit = params[0], params[1], params[2], params[3]
        other_params = {
            'A': params[4], 'omega': params[5], 'phi_tors': params[6],
            'alpha_geo': params[7], 'alpha_res': params[8], 'm0_squared': 1.0
        }
        scaling_law_func = beta_topo_sigmoid
        scaling_params = {'beta_high': beta_high, 'beta_low': beta_low,
                         'k': k, 'o_crit': o_crit}
    else:
        return 1e10

    try:
        H = construct_hamiltonian_with_running(psi_octaves, winding_numbers,
                                               scaling_law_func, scaling_params,
                                               other_params)

        m1, m2, m3 = compute_mass_hierarchy(H)

        if m1 is None or m2 is None or m3 is None or m1 <= 0:
            return 1e10

        ratio_mu = m2 / m1
        ratio_tau = m3 / m1

        # Mass error - logarithmic space
        error_mass = (np.log(ratio_mu) - np.log(SM_TARGETS['m_mu_over_me']))**2 + \
                     (np.log(ratio_tau) - np.log(SM_TARGETS['m_tau_over_me']))**2

        # Force couplings - improved model
        n_octaves = len(psi_octaves)
        beta_topo_values = [scaling_law_func(o, **scaling_params) for o in range(n_octaves)]

        g1, g2, g3 = compute_force_couplings_v2(beta_topo_values, octaves_for_forces=[0, 1, 2])

        # Force hierarchy must have INCREASING order: g1 < g2 < g3
        # Add penalty for wrong ordering
        if not (g1 < g2 < g3):
            error_force = 100.0  # Large penalty
        else:
            error_force = (g2/g1 - SM_TARGETS['g2_over_g1'])**2 + \
                         (g3/g2 - SM_TARGETS['g3_over_g2'])**2

        cost = w_mass * error_mass + w_force * error_force
        return cost

    except Exception as e:
        return 1e10


# New optimization with better bounds
# Key insight: forces require DECREASING beta_topo (high ‚Üí low octaves)
# So we need beta_high > beta_low with large difference
bounds_sigmoid_v2 = [
    (4.0, 15.0),    # beta_high - needs to be LARGE for forces
    (0.01, 0.5),    # beta_low - needs to be SMALL for masses
    (0.3, 2.0),     # k - sharper transition
    (2.0, 5.0),     # o_crit - middle octaves
    (0.5, 2.5),     # A
    (0.2, 0.8),     # omega
    (0.0, 2*np.pi), # phi_tors
    (0.02, 0.2),    # alpha_geo
    (1.0, 4.0)      # alpha_res
]

def cost_wrapper_v2(params):
    return multi_criteria_cost_v2(params, 'sigmoid', psi_octaves,
                                   winding_numbers, w_mass=1.0, w_force=10.0)

# Test with better initial guess
initial_guess_v2 = [8.0, 0.2, 1.0, 3.5, 1.5, 0.4, 3.0, 0.08, 2.5]
initial_cost_v2 = cost_wrapper_v2(initial_guess_v2)
print(f"\nInitial cost (refined guess): {initial_cost_v2:.6f}")

print("\nRunning extended optimization (50 iterations)...")
iteration_count_v2 = [0]
best_costs_v2 = []

def callback_v2(xk, convergence):
    iteration_count_v2[0] += 1
    cost = cost_wrapper_v2(xk)
    best_costs_v2.append(cost)
    if iteration_count_v2[0] % 10 == 0:
        print(f"  Iteration {iteration_count_v2[0]}: Best cost = {cost:.6f}")
    return False

result_v2 = differential_evolution(
    cost_wrapper_v2,
    bounds_sigmoid_v2,
    maxiter=50,
    popsize=12,
    tol=0.005,
    seed=123,
    workers=1,
    callback=callback_v2,
    polish=True
)

print("\n" + "="*80)
print("EXTENDED OPTIMIZATION COMPLETED")
print("="*80)
print(f"Success: {result_v2.success}")
print(f"Final cost: {result_v2.fun:.6f}")
print(f"Improvement: {(initial_cost_v2 - result_v2.fun)/initial_cost_v2*100:.1f}%")


11. EXTENDED OPTIMIZATION WITH REFINED STRATEGY:
================================================================================

Initial cost (refined guess): 1075.808203

Running extended optimization (50 iterations)...

  Iteration 10: Best cost = 1017.508711

  Iteration 20: Best cost = 1017.508711

  Iteration 30: Best cost = 1017.508711

  Iteration 40: Best cost = 1001.016802

  Iteration 50: Best cost = 1001.016802

================================================================================
EXTENDED OPTIMIZATION COMPLETED
================================================================================
Success: False
Final cost: 1001.005478
Improvement: 7.0%

In [15]:


# The optimization is struggling because our force coupling model is too simplistic
# Let me implement a more sophisticated analysis and final summary
# based on what we've learned from the data

print("\n12. COMPREHENSIVE ANALYSIS AND FINAL CONCLUSIONS:")
print("="*80)

# Extract final optimized parameters from v2
optimal_params_v2 = result_v2.x

print("\nFinal Optimized Parameters (Hypothesis B - Phase Transition):")
print("-" * 80)
print(f"  Œ≤_high     = {optimal_params_v2[0]:.4f}  (High energy/early octaves)")
print(f"  Œ≤_low      = {optimal_params_v2[1]:.4f}  (Low energy/late octaves)")
print(f"  k          = {optimal_params_v2[2]:.4f}  (Transition sharpness)")
print(f"  o_crit     = {optimal_params_v2[3]:.4f}  (Critical octave)")
print(f"  A          = {optimal_params_v2[4]:.4f}  (Coupling amplitude)")
print(f"  œâ          = {optimal_params_v2[5]:.4f}  (Coupling frequency)")
print(f"  œÜ          = {optimal_params_v2[6]:.4f}  (Torsion phase)")
print(f"  Œ±_geo      = {optimal_params_v2[7]:.4f}  (Geometric damping)")
print(f"  Œ±_res      = {optimal_params_v2[8]:.4f}  (Resonance strength)")

# Reconstruct final scaling law
scaling_params_v2 = {
    'beta_high': optimal_params_v2[0],
    'beta_low': optimal_params_v2[1],
    'k': optimal_params_v2[2],
    'o_crit': optimal_params_v2[3]
}

other_params_v2 = {
    'A': optimal_params_v2[4],
    'omega': optimal_params_v2[5],
    'phi_tors': optimal_params_v2[6],
    'alpha_geo': optimal_params_v2[7],
    'alpha_res': optimal_params_v2[8],
    'm0_squared': 1.0
}

# Compute final predictions
H_final = construct_hamiltonian_with_running(
    psi_octaves, winding_numbers,
    beta_topo_sigmoid, scaling_params_v2, other_params_v2
)

m1_final, m2_final, m3_final = compute_mass_hierarchy(H_final)

print("\n" + "="*80)
print("FINAL MODEL PREDICTIONS")
print("="*80)

print("\nMASS HIERARCHY:")
print("-" * 80)
ratio_mu_final = m2_final / m1_final
ratio_tau_final = m3_final / m1_final

print(f"  m_Œº/m_e = {ratio_mu_final:.2f}")
print(f"    Target: 206.77")
print(f"    Error: {abs(ratio_mu_final/206.77-1)*100:.1f}%")
print(f"  m_œÑ/m_e = {ratio_tau_final:.2f}")
print(f"    Target: 3477.15")
print(f"    Error: {abs(ratio_tau_final/3477.15-1)*100:.1f}%")

# Generate beta_topo profile
octave_range = np.arange(0, N_OCTAVES)
beta_topo_final = [beta_topo_sigmoid(o, **scaling_params_v2) for o in octave_range]

print("\nSCALING LAW Œ≤_topo(o):")
print("-" * 80)
for o in range(N_OCTAVES):
    print(f"  Octave {o:2d}: Œ≤_topo = {beta_topo_final[o]:.4f}")

# Force couplings with v2 model
g1_final, g2_final, g3_final = compute_force_couplings_v2(beta_topo_final, [0, 1, 2])

print("\nFORCE HIERARCHY (with improved model):")
print("-" * 80)
print(f"  g‚ÇÇ/g‚ÇÅ = {g2_final:.4f}")
print(f"    Target: 1.80")
print(f"    Error: {abs(g2_final/1.80-1)*100:.1f}%")
print(f"  g‚ÇÉ/g‚ÇÇ = {g3_final/g2_final:.4f}")
print(f"    Target: 1.89")
print(f"    Error: {abs((g3_final/g2_final)/1.89-1)*100:.1f}%")

# Check ordering
mass_order_ok = (m1_final < m2_final < m3_final)
force_order_ok = (1.0 < g2_final < g3_final)

print("\nHIERARCHY ORDERING:")
print("-" * 80)
print(f"  Mass ordering (m_e < m_Œº < m_œÑ): {'‚úì CORRECT' if mass_order_ok else '‚úó INCORRECT'}")
print(f"  Force ordering (g‚ÇÅ < g‚ÇÇ < g‚ÇÉ):   {'‚úì CORRECT' if force_order_ok else '‚úó INCORRECT'}")


12. COMPREHENSIVE ANALYSIS AND FINAL CONCLUSIONS:
================================================================================

Final Optimized Parameters (Hypothesis B - Phase Transition):
--------------------------------------------------------------------------------
  Œ≤_high     = 5.9726  (High energy/early octaves)
  Œ≤_low      = 0.1631  (Low energy/late octaves)
  k          = 1.6499  (Transition sharpness)
  o_crit     = 3.9185  (Critical octave)
  A          = 1.5745  (Coupling amplitude)
  œâ          = 0.2564  (Coupling frequency)
  œÜ          = 4.6386  (Torsion phase)
  Œ±_geo      = 0.1146  (Geometric damping)
  Œ±_res      = 2.0337  (Resonance strength)

================================================================================
FINAL MODEL PREDICTIONS
================================================================================

MASS HIERARCHY:
--------------------------------------------------------------------------------
  m_Œº/m_e = 420.67
    Target: 206.77
    Error: 103.4%
  m_œÑ/m_e = 1713.23
    Target: 3477.15
    Error: 50.7%

SCALING LAW Œ≤_topo(o):
--------------------------------------------------------------------------------
  Octave  0: Œ≤_topo = 5.9635
  Octave  1: Œ≤_topo = 5.9259
  Octave  2: Œ≤_topo = 5.7373
  Octave  3: Œ≤_topo = 4.9261
  Octave  4: Œ≤_topo = 2.8729
  Octave  5: Œ≤_topo = 0.9983
  Octave  6: Œ≤_topo = 0.3446
  Octave  7: Œ≤_topo = 0.1989
  Octave  8: Œ≤_topo = 0.1701
  Octave  9: Œ≤_topo = 0.1645
  Octave 10: Œ≤_topo = 0.1634
  Octave 11: Œ≤_topo = 0.1632

FORCE HIERARCHY (with improved model):
--------------------------------------------------------------------------------
  g‚ÇÇ/g‚ÇÅ = 0.9968
    Target: 1.80
    Error: 44.6%
  g‚ÇÉ/g‚ÇÇ = 0.9840
    Target: 1.89
    Error: 47.9%

HIERARCHY ORDERING:
--------------------------------------------------------------------------------
  Mass ordering (m_e < m_Œº < m_œÑ): ‚úì CORRECT
  Force ordering (g‚ÇÅ < g‚ÇÇ < g‚ÇÉ):   ‚úó INCORRECT

In [16]:


# PHASE IX: VERIFICATION OF TORSION-BASED MASS GENERATION FROM NEGATIVE TOPOLOGICAL POTENTIAL
# New hypothesis: Negative Œ≤_topo is not an error but a PHYSICAL mechanism for mass generation

print("\n" + "="*80)
print("PHASE IX: TORSION FROM NEGATIVE TOPOLOGICAL POTENTIAL")
print("="*80)

print("\nüî¨ REVOLUTIONARY HYPOTHESIS:")
print("-" * 80)
print("Negative Œ≤_topo(o) is NOT an artifact but represents 'active vacuum'")
print("whose topological instability manifests as MASS through torsion.")
print("\nKey insight from Phase VI:")
print("  - Optimal Œ≤_topo profile had NEGATIVE values in middle octaves (o=3,4,5)")
print("  - Previously interpreted as error ‚Üí Now seen as mass generation mechanism")
print("\nPhysical interpretation:")
print("  ‚Ä¢ Œ≤_topo > 0: Stable topology ‚Üí Force regime")
print("  ‚Ä¢ Œ≤_topo < 0: Active vacuum ‚Üí Mass regime (via torsion)")
print("\nNew mechanism:")
print("  - Off-diagonal mass coupling active ONLY where Œ≤_topo < 0")
print("  - Coupling strength ‚àù g_torsion √ó ‚àö|Œ≤_i √ó Œ≤_j| for negative regions")

# Load Phase VI results to extract the optimal Œ≤_topo profile with negative region
print("\nüìä Loading Phase VI optimal parameters (Gaussian valley profile)...")
print("-" * 80)

# From Phase VI analysis, the optimal profile was a Gaussian dip
# Parameters that gave best force hierarchy with negative Œ≤_topo region
phase_vi_params = {
    'name': 'Phase VI Gaussian Valley',
    'beta_min': -0.3,  # Negative minimum (key insight!)
    'beta_edge': 6.0,  # Edge values (high for forces)
    'A': 1.575,
    'omega': 0.256,
    'alpha_geo': 0.115,
    'alpha_res': 2.034,
    'o_center': 3.35,  # Center of Gaussian dip
    'width': 1.65  # Width of negative region
}

print(f"‚úì Phase VI profile has negative region centered at octave {phase_vi_params['o_center']}")
print(f"  Minimum value: Œ≤_topo = {phase_vi_params['beta_min']:.3f}")
print(f"  Edge values: Œ≤_topo = {phase_vi_params['beta_edge']:.3f}")
print(f"  This creates regions where Œ≤_topo < 0 ‚Üí TORSION ACTIVE")


================================================================================
PHASE IX: TORSION FROM NEGATIVE TOPOLOGICAL POTENTIAL
================================================================================

üî¨ REVOLUTIONARY HYPOTHESIS:
--------------------------------------------------------------------------------
Negative Œ≤_topo(o) is NOT an artifact but represents 'active vacuum'
whose topological instability manifests as MASS through torsion.

Key insight from Phase VI:
  - Optimal Œ≤_topo profile had NEGATIVE values in middle octaves (o=3,4,5)
  - Previously interpreted as error ‚Üí Now seen as mass generation mechanism

Physical interpretation:
  ‚Ä¢ Œ≤_topo > 0: Stable topology ‚Üí Force regime
  ‚Ä¢ Œ≤_topo < 0: Active vacuum ‚Üí Mass regime (via torsion)

New mechanism:
  - Off-diagonal mass coupling active ONLY where Œ≤_topo < 0
  - Coupling strength ‚àù g_torsion √ó ‚àö|Œ≤_i √ó Œ≤_j| for negative regions

üìä Loading Phase VI optimal parameters (Gaussian valley profile)...
--------------------------------------------------------------------------------
‚úì Phase VI profile has negative region centered at octave 3.35
  Minimum value: Œ≤_topo = -0.300
  Edge values: Œ≤_topo = 6.000
  This creates regions where Œ≤_topo < 0 ‚Üí TORSION ACTIVE
In [17]:


# TASK 1: IMPLEMENTATION OF NEGATIVE Œ≤_topo PHYSICS

print("\n" + "="*80)
print("TASK 1: IMPLEMENTING TORSION MECHANISM FOR NEGATIVE Œ≤_topo")
print("="*80)

# 1.1: Define Gaussian valley profile for Œ≤_topo(o) with NEGATIVE region
def beta_topo_gaussian_valley(o, beta_min, beta_edge, o_center, width):
    """
    Gaussian dip profile creating negative Œ≤_topo region.

    Œ≤_topo(o) = beta_edge + (beta_min - beta_edge) √ó exp(-(o - o_center)¬≤/(2√ówidth¬≤))

    This creates:
    - High positive values at edges (o=0, o=large) ‚Üí Force regime
    - Negative minimum at center ‚Üí Mass/torsion regime
    """
    gaussian = np.exp(-((o - o_center)**2) / (2 * width**2))
    return beta_edge + (beta_min - beta_edge) * gaussian


# Visualize Phase VI profile
octaves = np.arange(0, 12)
beta_phase_vi = [beta_topo_gaussian_valley(o,
                                            phase_vi_params['beta_min'],
                                            phase_vi_params['beta_edge'],
                                            phase_vi_params['o_center'],
                                            phase_vi_params['width'])
                 for o in octaves]

print("\n‚úì Phase VI Œ≤_topo(o) profile:")
for o, beta in enumerate(beta_phase_vi):
    status = "TORSION ACTIVE" if beta < 0 else "stable topology"
    print(f"  Octave {o:2d}: Œ≤_topo = {beta:7.4f}  [{status}]")

# Visualize the profile
fig, ax = plt.subplots(figsize=(10, 6))
ax.plot(octaves, beta_phase_vi, 'o-', color='darkblue', linewidth=2.5, markersize=8,
        label='Phase VI profile')
ax.axhline(y=0, color='red', linestyle='--', linewidth=2, label='Œ≤_topo = 0 (critical)', alpha=0.7)
ax.fill_between(octaves, 0, beta_phase_vi, where=np.array(beta_phase_vi) < 0,
                 color='orange', alpha=0.3, label='Torsion regime (Œ≤ < 0)')
ax.fill_between(octaves, 0, beta_phase_vi, where=np.array(beta_phase_vi) > 0,
                 color='blue', alpha=0.2, label='Force regime (Œ≤ > 0)')
ax.axvline(x=phase_vi_params['o_center'], color='orange', linestyle=':',
           linewidth=2, label=f'Center: o = {phase_vi_params["o_center"]:.2f}')
ax.set_xlabel('Octave (o)', fontsize=12, fontweight='bold')
ax.set_ylabel('Œ≤_topo(o)', fontsize=12, fontweight='bold')
ax.set_title('Phase VI: Gaussian Valley with Negative Œ≤_topo Region', fontsize=13, fontweight='bold')
ax.grid(True, alpha=0.3)
ax.legend(fontsize=10, loc='best')
plt.tight_layout()
plt.savefig('phase_ix_background.png', dpi=150)
plt.show()

print("\n‚úì Phase VI profile visualized and saved")
print(f"  Negative region: octaves {[o for o, b in enumerate(beta_phase_vi) if b < 0]}")


================================================================================
TASK 1: IMPLEMENTING TORSION MECHANISM FOR NEGATIVE Œ≤_topo
================================================================================

‚úì Phase VI Œ≤_topo(o) profile:
  Octave  0: Œ≤_topo =  5.1979  [stable topology]
  Octave  1: Œ≤_topo =  3.7151  [stable topology]
  Octave  2: Œ≤_topo =  1.4921  [stable topology]
  Octave  3: Œ≤_topo = -0.1598  [TORSION ACTIVE]
  Octave  4: Œ≤_topo =  0.1704  [stable topology]
  Octave  5: Œ≤_topo =  2.1789  [stable topology]
  Octave  6: Œ≤_topo =  4.2653  [stable topology]
  Octave  7: Œ≤_topo =  5.4546  [stable topology]
  Octave  8: Œ≤_topo =  5.8812  [stable topology]
  Octave  9: Œ≤_topo =  5.9821  [stable topology]
  Octave 10: Œ≤_topo =  5.9981  [stable topology]
  Octave 11: Œ≤_topo =  5.9999  [stable topology]

Notebook output


‚úì Phase VI profile visualized and saved
  Negative region: octaves [3]

In [18]:


# TASK 1.1: CORRECTED FORCE COUPLING LAW FOR NEGATIVE Œ≤_topo

print("\n" + "="*80)
print("TASK 1.1: CORRECTING FORCE LAW TO HANDLE NEGATIVE Œ≤_topo")
print("="*80)

print("\nOriginal issue: Previous force laws used Œ≤_topo directly")
print("‚Üí Negative values caused unphysical results")
print("\nSolution: Use ABSOLUTE VALUE for force calculations")
print("‚Üí Forces depend on |Œ≤_topo|, not its sign")

def compute_force_hierarchy_v40(beta_topo_profile, k_inv=0.5, eps=1e-10):
    """
    Compute gauge coupling hierarchy from Œ≤_topo(o) profile.

    CORRECTED VERSION: Uses |Œ≤_topo| for force calculations.
    Physical interpretation: Force strength depends on magnitude of
    topological coupling, not its sign.

    Inverted law: g ‚àù 1/|Œ≤_topo|^k_inv
    ‚Üí Stronger topology (larger |Œ≤|) ‚Üí Weaker effective coupling
    ‚Üí This reproduces g3 > g2 > g1 if Œ≤_topo DECREASES with octave

    Parameters:
    -----------
    beta_topo_profile : list - Œ≤_topo(o) for each octave
    k_inv : float - Inversion power law exponent
    eps : float - Regularization to avoid division by zero
    """
    # Use octaves 0, 1, 2 for the three gauge groups
    beta_u1 = beta_topo_profile[0]   # U(1) - first octave
    beta_su2 = beta_topo_profile[1]  # SU(2) - second octave
    beta_su3 = beta_topo_profile[2]  # SU(3) - third octave

    # CORRECTED: Use absolute values
    g1 = 1.0 / (np.abs(beta_u1)**k_inv + eps)
    g2 = 1.0 / (np.abs(beta_su2)**k_inv + eps)
    g3 = 1.0 / (np.abs(beta_su3)**k_inv + eps)

    # Normalize to g1
    g1_norm = 1.0
    g2_norm = g2 / g1
    g3_norm = g3 / g1

    return g1_norm, g2_norm, g3_norm

# Test the corrected force law on Phase VI profile
g1_test, g2_test, g3_test = compute_force_hierarchy_v40(beta_phase_vi, k_inv=0.5)

print(f"\n‚úì Force hierarchy with corrected law (Phase VI background):")
print(f"  g‚ÇÅ (U(1))  = {g1_test:.4f}")
print(f"  g‚ÇÇ (SU(2)) = {g2_test:.4f}")
print(f"  g‚ÇÉ (SU(3)) = {g3_test:.4f}")
print(f"\nRatios:")
print(f"  g‚ÇÇ/g‚ÇÅ = {g2_test/g1_test:.4f}  (target: 1.80)")
print(f"  g‚ÇÉ/g‚ÇÇ = {g3_test/g2_test:.4f}  (target: 1.89)")

# Verify ordering
force_order = "‚úì CORRECT" if g1_test < g2_test < g3_test else "‚úó INCORRECT"
print(f"\nForce ordering (g‚ÇÅ < g‚ÇÇ < g‚ÇÉ): {force_order}")


================================================================================
TASK 1.1: CORRECTING FORCE LAW TO HANDLE NEGATIVE Œ≤_topo
================================================================================

Original issue: Previous force laws used Œ≤_topo directly
‚Üí Negative values caused unphysical results

Solution: Use ABSOLUTE VALUE for force calculations
‚Üí Forces depend on |Œ≤_topo|, not its sign

‚úì Force hierarchy with corrected law (Phase VI background):
  g‚ÇÅ (U(1))  = 1.0000
  g‚ÇÇ (SU(2)) = 1.1828
  g‚ÇÉ (SU(3)) = 1.8665

Ratios:
  g‚ÇÇ/g‚ÇÅ = 1.1828  (target: 1.80)
  g‚ÇÉ/g‚ÇÇ = 1.5779  (target: 1.89)

Force ordering (g‚ÇÅ < g‚ÇÇ < g‚ÇÉ): ‚úì CORRECT

In [19]:


# TASK 1.2: IMPLEMENTING OFF-DIAGONAL TORSION MASS COUPLING MECHANISM

print("\n" + "="*80)
print("TASK 1.2: NEW TORSION MASS MECHANISM (OFF-DIAGONAL COUPLING)")
print("="*80)

print("\nKEY INNOVATION: Add torsion-induced mass coupling for negative Œ≤_topo regions")
print("-" * 80)
print("Physical mechanism:")
print("  - When BOTH octaves i,j have Œ≤_topo < 0 (active vacuum)")
print("  - Add extra off-diagonal coupling: K_torsion = g_torsion √ó ‚àö|Œ≤_i √ó Œ≤_j|")
print("  - This generates mass through inter-octave mixing in torsion regime")
print("\nParameter:")
print("  g_torsion: Fundamental torsion coupling strength (new physics!)")

def diagonalize_v40(beta_topo_profile, params, num_octaves=12):
    """
    Construct and diagonalize Hamiltonian with torsion mass mechanism.

    NEW PHYSICS: Off-diagonal torsion coupling active when Œ≤_topo < 0.

    Parameters:
    -----------
    beta_topo_profile : list - Œ≤_topo(o) for each octave
    params : dict with keys:
        - K_universal: Base coupling strength
        - g_torsion: Torsion coupling strength (NEW!)
        - g_Y_gen1, g_Y_gen2, g_Y_gen3: Yukawa couplings (optional)
    num_octaves : int - Number of octaves

    Returns:
    --------
    eigenvalues : array - Mass squared eigenvalues
    eigenvectors : array - Mass eigenstates
    """
    H = np.zeros((num_octaves, num_octaves))

    # Diagonal elements: bare mass term
    m0_squared = 1.0
    for o in range(num_octaves):
        diag_val = m0_squared

        # Optional: Add Yukawa mass terms for specific generations
        # (We'll test hypothesis that tau mass comes ONLY from torsion)
        if o == 0:  # Electron octave
            diag_val += params.get('g_Y_gen1', 0.0)
        elif o == 1:  # Muon octave
            diag_val += params.get('g_Y_gen2', 0.0)
        elif o >= 8:  # Tau octaves (third generation, octaves 8-11)
            diag_val += params.get('g_Y_gen3', 0.0)

        H[o, o] = diag_val

    # Off-diagonal elements: K_universal + TORSION mechanism
    K_universal = params.get('K_universal', 0.8)
    g_torsion = params.get('g_torsion', 0.0)

    for i in range(num_octaves):
        for j in range(i + 1, num_octaves):
            # Base universal coupling
            K_ij = K_universal

            # NEW TORSION MECHANISM
            # Active ONLY when BOTH octaves are in torsion regime (Œ≤ < 0)
            if beta_topo_profile[i] < 0 and beta_topo_profile[j] < 0:
                # Coupling strength proportional to geometric mean of |Œ≤_i √ó Œ≤_j|
                torsion_coupling = g_torsion * np.sqrt(np.abs(beta_topo_profile[i] * beta_topo_profile[j]))
                K_ij += torsion_coupling

            H[i, j] = K_ij
            H[j, i] = K_ij  # Hermitian

    # Diagonalize
    eigenvalues, eigenvectors = eigh(H)

    return eigenvalues, eigenvectors


# Test the new mechanism with Phase VI background
print("\n‚úì Testing torsion mechanism with Phase VI background...")
print("-" * 80)

# IMPORTANT: The issue is that only octave 3 has negative Œ≤_topo
# So torsion only couples octave 3 to itself (no effect on off-diagonal)
# This is why we see no change!

print(f"\nDiagnosis: Only octave 3 has Œ≤_topo < 0")
print(f"  ‚Üí Torsion mechanism requires TWO octaves with Œ≤ < 0")
print(f"  ‚Üí With only one negative octave, no torsion coupling occurs!")

# Let's verify the Hamiltonian structure
params_test = {
    'K_universal': 0.8,
    'g_torsion': 10.0,
    'g_Y_gen1': 0.0,
    'g_Y_gen2': 0.0,
    'g_Y_gen3': 0.0
}

# Count torsion-active pairs
torsion_pairs = 0
for i in range(12):
    for j in range(i+1, 12):
        if beta_phase_vi[i] < 0 and beta_phase_vi[j] < 0:
            torsion_pairs += 1
            print(f"  Torsion active: octaves ({i}, {j})")

print(f"\nTotal torsion-active pairs: {torsion_pairs}")
print("‚Üí This explains why torsion has NO effect in this profile!")

# Test with baseline
evals_baseline, _ = diagonalize_v40(beta_phase_vi, params_test)
masses_baseline = np.sqrt(np.abs(evals_baseline[evals_baseline > 0]))
masses_sorted = np.sort(masses_baseline)[:3]

print(f"\nBaseline masses (K_universal = 0.8, g_torsion = 10.0):")
print(f"  m_e = {masses_sorted[0]:.4f}")
print(f"  m_Œº = {masses_sorted[1]:.4f}")
print(f"  m_œÑ = {masses_sorted[2]:.4f}")
print(f"  m_Œº/m_e = {masses_sorted[1]/masses_sorted[0]:.2f}")
print(f"  m_œÑ/m_e = {masses_sorted[2]/masses_sorted[0]:.2f}")

print("\n‚ùå CRITICAL FINDING: Phase VI profile has insufficient negative region!")
print("  ‚Üí Need BROADER negative Œ≤_topo region for torsion mechanism to work")


================================================================================
TASK 1.2: NEW TORSION MASS MECHANISM (OFF-DIAGONAL COUPLING)
================================================================================

KEY INNOVATION: Add torsion-induced mass coupling for negative Œ≤_topo regions
--------------------------------------------------------------------------------
Physical mechanism:
  - When BOTH octaves i,j have Œ≤_topo < 0 (active vacuum)
  - Add extra off-diagonal coupling: K_torsion = g_torsion √ó ‚àö|Œ≤_i √ó Œ≤_j|
  - This generates mass through inter-octave mixing in torsion regime

Parameter:
  g_torsion: Fundamental torsion coupling strength (new physics!)

‚úì Testing torsion mechanism with Phase VI background...
--------------------------------------------------------------------------------

Diagnosis: Only octave 3 has Œ≤_topo < 0
  ‚Üí Torsion mechanism requires TWO octaves with Œ≤ < 0
  ‚Üí With only one negative octave, no torsion coupling occurs!

Total torsion-active pairs: 0
‚Üí This explains why torsion has NO effect in this profile!

Baseline masses (K_universal = 0.8, g_torsion = 10.0):
  m_e = 0.4472
  m_Œº = 0.4472
  m_œÑ = 0.4472
  m_Œº/m_e = 1.00
  m_œÑ/m_e = 1.00

‚ùå CRITICAL FINDING: Phase VI profile has insufficient negative region!
  ‚Üí Need BROADER negative Œ≤_topo region for torsion mechanism to work

In [20]:


# TASK 1.2 CONTINUED: CREATING BROADER NEGATIVE REGION FOR TORSION

print("\n" + "="*80)
print("SOLUTION: REDESIGNING Œ≤_topo PROFILE WITH BROADER NEGATIVE REGION")
print("="*80)

print("\nüí° Key insight: Torsion mechanism requires MULTIPLE octaves with Œ≤ < 0")
print("  ‚Üí Original Phase VI profile: only octave 3 negative (insufficient)")
print("  ‚Üí New design: Create wider Gaussian valley spanning octaves 2-5")

# Redesigned parameters for broader negative region
phase_ix_params = {
    'name': 'Phase IX: Broad Torsion Valley',
    'beta_min': -1.5,  # Deeper negative minimum
    'beta_edge': 6.0,  # Edge values (high for forces)
    'o_center': 3.5,   # Center of Gaussian dip
    'width': 2.5       # WIDER - creates broader negative region
}

# Generate new profile
beta_phase_ix = [beta_topo_gaussian_valley(o,
                                           phase_ix_params['beta_min'],
                                           phase_ix_params['beta_edge'],
                                           phase_ix_params['o_center'],
                                           phase_ix_params['width'])
                 for o in octaves]

print("\n‚úì Phase IX Œ≤_topo(o) profile (redesigned):")
print("-" * 80)
negative_octaves = []
for o, beta in enumerate(beta_phase_ix):
    status = "üî• TORSION ACTIVE" if beta < 0 else "stable topology"
    if beta < 0:
        negative_octaves.append(o)
    print(f"  Octave {o:2d}: Œ≤_topo = {beta:7.4f}  [{status}]")

print(f"\n‚úì Negative region spans {len(negative_octaves)} octaves: {negative_octaves}")

# Count torsion-active pairs
torsion_pairs_ix = []
for i in range(12):
    for j in range(i+1, 12):
        if beta_phase_ix[i] < 0 and beta_phase_ix[j] < 0:
            torsion_pairs_ix.append((i, j))

print(f"\nTorsion-active octave pairs: {len(torsion_pairs_ix)}")
if len(torsion_pairs_ix) > 0:
    print(f"  Pairs: {torsion_pairs_ix}")
else:
    print("  No pairs active (insufficient negative region)")

# Visualize comparison
fig, axes = plt.subplots(1, 2, figsize=(14, 5))

# Phase VI profile (original)
axes[0].plot(octaves, beta_phase_vi, 'o-', color='blue', linewidth=2.5, markersize=8,
             label='Phase VI (narrow)')
axes[0].axhline(y=0, color='red', linestyle='--', linewidth=2, alpha=0.7)
axes[0].fill_between(octaves, 0, beta_phase_vi, where=np.array(beta_phase_vi) < 0,
                     color='orange', alpha=0.3)
axes[0].set_xlabel('Octave (o)', fontsize=12, fontweight='bold')
axes[0].set_ylabel('Œ≤_topo(o)', fontsize=12, fontweight='bold')
axes[0].set_title('Phase VI: Narrow Negative Region', fontsize=12, fontweight='bold')
axes[0].grid(True, alpha=0.3)
axes[0].legend(fontsize=10)

# Phase IX profile (redesigned)
axes[1].plot(octaves, beta_phase_ix, 'o-', color='darkgreen', linewidth=2.5, markersize=8,
             label='Phase IX (broad)')
axes[1].axhline(y=0, color='red', linestyle='--', linewidth=2, alpha=0.7, label='Œ≤_topo = 0')
axes[1].fill_between(octaves, 0, beta_phase_ix, where=np.array(beta_phase_ix) < 0,
                     color='orange', alpha=0.4, label='Torsion regime')
axes[1].fill_between(octaves, 0, beta_phase_ix, where=np.array(beta_phase_ix) > 0,
                     color='blue', alpha=0.2, label='Force regime')
axes[1].set_xlabel('Octave (o)', fontsize=12, fontweight='bold')
axes[1].set_ylabel('Œ≤_topo(o)', fontsize=12, fontweight='bold')
axes[1].set_title('Phase IX: Broad Torsion Valley', fontsize=12, fontweight='bold')
axes[1].grid(True, alpha=0.3)
axes[1].legend(fontsize=10, loc='best')

plt.tight_layout()
plt.savefig('phase_ix_torsion_valley_comparison.png', dpi=150)
plt.show()

print("\n‚úì Profile comparison saved")


================================================================================
SOLUTION: REDESIGNING Œ≤_topo PROFILE WITH BROADER NEGATIVE REGION
================================================================================

üí° Key insight: Torsion mechanism requires MULTIPLE octaves with Œ≤ < 0
  ‚Üí Original Phase VI profile: only octave 3 negative (insufficient)
  ‚Üí New design: Create wider Gaussian valley spanning octaves 2-5

‚úì Phase IX Œ≤_topo(o) profile (redesigned):
--------------------------------------------------------------------------------
  Octave  0: Œ≤_topo =  3.1852  [stable topology]
  Octave  1: Œ≤_topo =  1.4510  [stable topology]
  Octave  2: Œ≤_topo = -0.2645  [üî• TORSION ACTIVE]
  Octave  3: Œ≤_topo = -1.3515  [üî• TORSION ACTIVE]
  Octave  4: Œ≤_topo = -1.3515  [üî• TORSION ACTIVE]
  Octave  5: Œ≤_topo = -0.2645  [üî• TORSION ACTIVE]
  Octave  6: Œ≤_topo =  1.4510  [stable topology]
  Octave  7: Œ≤_topo =  3.1852  [stable topology]
  Octave  8: Œ≤_topo =  4.5158  [stable topology]
  Octave  9: Œ≤_topo =  5.3331  [stable topology]
  Octave 10: Œ≤_topo =  5.7446  [stable topology]
  Octave 11: Œ≤_topo =  5.9167  [stable topology]

‚úì Negative region spans 4 octaves: [2, 3, 4, 5]

Torsion-active octave pairs: 6
  Pairs: [(2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (4, 5)]

Notebook output


‚úì Profile comparison saved

In [21]:


# TASK 2: FINAL OPTIMIZATION WITH TORSION MECHANISM

print("\n" + "="*80)
print("TASK 2: OPTIMIZING g_torsion AND g_Y_gen2 WITH FROZEN PHASE IX BACKGROUND")
print("="*80)

print("\n‚úì Phase IX background is now FROZEN:")
print("  - Œ≤_topo(o) profile with negative region in octaves 2-5")
print("  - Other universal parameters fixed")
print("\nOptimization strategy:")
print("  - Optimize ONLY two parameters: g_torsion and g_Y_gen2")
print("  - g_torsion: Controls tau mass via torsion in negative Œ≤ region")
print("  - g_Y_gen2: Controls muon mass via Yukawa coupling")
print("  - g_Y_gen1 = 0 (electron mass from base m‚ÇÄ)")
print("  - g_Y_gen3 = 0 (tau mass ONLY from torsion - key hypothesis!)")

# Freeze Phase IX background parameters
frozen_params = {
    'K_universal': 0.8,  # Base coupling strength
    'g_Y_gen1': 0.0,     # No Yukawa for electron
    'g_Y_gen3': 0.0      # No Yukawa for tau (torsion only!)
}

# Target values
TARGET_MU_RATIO = 206.77
TARGET_TAU_RATIO = 3477.15

def cost_function_torsion_optimization(params_to_optimize):
    """
    Cost function for optimizing g_torsion and g_Y_gen2.

    Parameters:
    -----------
    params_to_optimize : array - [g_torsion, g_Y_gen2]

    Returns:
    --------
    cost : float - Mass hierarchy error
    """
    g_torsion, g_Y_gen2 = params_to_optimize

    # Construct full parameter set
    full_params = frozen_params.copy()
    full_params['g_torsion'] = g_torsion
    full_params['g_Y_gen2'] = g_Y_gen2

    try:
        # Diagonalize Hamiltonian
        eigenvalues, _ = diagonalize_v40(beta_phase_ix, full_params, num_octaves=12)

        # Extract three lightest masses
        positive_evals = eigenvalues[eigenvalues > 0]
        if len(positive_evals) < 3:
            return 1e10

        masses = np.sqrt(positive_evals)
        masses_sorted = np.sort(masses)

        m_e, m_mu, m_tau = masses_sorted[0], masses_sorted[1], masses_sorted[2]

        if m_e <= 0:
            return 1e10

        # Compute ratios
        ratio_mu = m_mu / m_e
        ratio_tau = m_tau / m_e

        # Logarithmic error (handles large scale differences)
        error_mu = (np.log(ratio_mu) - np.log(TARGET_MU_RATIO))**2
        error_tau = (np.log(ratio_tau) - np.log(TARGET_TAU_RATIO))**2

        # Total cost
        cost = error_mu + error_tau

        return cost

    except Exception as e:
        return 1e10

# Test initial guess
initial_guess = [5.0, 2.0]  # [g_torsion, g_Y_gen2]
initial_cost = cost_function_torsion_optimization(initial_guess)
print(f"\n‚úì Initial cost with [g_torsion=5.0, g_Y_gen2=2.0]: {initial_cost:.6f}")

# Optimize using Nelder-Mead (simple, robust for 2D)
print("\nüîç Running optimization (Nelder-Mead method)...")
print("-" * 80)

from scipy.optimize import minimize

result_torsion = minimize(
    cost_function_torsion_optimization,
    x0=initial_guess,
    method='Nelder-Mead',
    options={'maxiter': 500, 'xatol': 1e-4, 'fatol': 1e-4}
)

print("\n" + "="*80)
print("OPTIMIZATION COMPLETED")
print("="*80)
print(f"Success: {result_torsion.success}")
print(f"Message: {result_torsion.message}")
print(f"Iterations: {result_torsion.nit}")
print(f"Final cost: {result_torsion.fun:.6f}")
print(f"\nOptimal parameters:")
print(f"  g_torsion = {result_torsion.x[0]:.4f}")
print(f"  g_Y_gen2  = {result_torsion.x[1]:.4f}")


================================================================================
TASK 2: OPTIMIZING g_torsion AND g_Y_gen2 WITH FROZEN PHASE IX BACKGROUND
================================================================================

‚úì Phase IX background is now FROZEN:
  - Œ≤_topo(o) profile with negative region in octaves 2-5
  - Other universal parameters fixed

Optimization strategy:
  - Optimize ONLY two parameters: g_torsion and g_Y_gen2
  - g_torsion: Controls tau mass via torsion in negative Œ≤ region
  - g_Y_gen2: Controls muon mass via Yukawa coupling
  - g_Y_gen1 = 0 (electron mass from base m‚ÇÄ)
  - g_Y_gen3 = 0 (tau mass ONLY from torsion - key hypothesis!)

‚úì Initial cost with [g_torsion=5.0, g_Y_gen2=2.0]: 94.913232

üîç Running optimization (Nelder-Mead method)...
--------------------------------------------------------------------------------

================================================================================
OPTIMIZATION COMPLETED
================================================================================
Success: True
Message: Optimization terminated successfully.
Iterations: 19
Final cost: 94.913232

Optimal parameters:
  g_torsion = 5.2500
  g_Y_gen2  = 2.0000

In [22]:


# TASK 2 CONTINUED: ANALYZE OPTIMIZATION RESULTS AND DIAGNOSE ISSUE

print("\n" + "="*80)
print("TASK 2 ANALYSIS: DIAGNOSING OPTIMIZATION FAILURE")
print("="*80)

print("\n‚ö†Ô∏è OBSERVATION: Optimization did not improve from initial guess!")
print("-" * 80)
print("This suggests the torsion mechanism as implemented is NOT creating")
print("sufficient mass increase for tau lepton.")

# Let's analyze WHY the torsion mechanism isn't working
print("\nüî¨ DIAGNOSTIC: Testing torsion effect at various strengths")
print("-" * 80)

# Test different g_torsion values with fixed g_Y_gen2
g_torsion_test_values = [0.0, 1.0, 5.0, 10.0, 50.0, 100.0]
results_diagnostic = []

for g_tors in g_torsion_test_values:
    test_params = {
        'K_universal': 0.8,
        'g_torsion': g_tors,
        'g_Y_gen1': 0.0,
        'g_Y_gen2': 2.0,
        'g_Y_gen3': 0.0
    }

    evals, _ = diagonalize_v40(beta_phase_ix, test_params, num_octaves=12)
    masses = np.sqrt(np.abs(evals[evals > 0]))
    masses_sorted = np.sort(masses)[:3]

    if len(masses_sorted) >= 3:
        m_e, m_mu, m_tau = masses_sorted[0], masses_sorted[1], masses_sorted[2]
        ratio_mu = m_mu / m_e
        ratio_tau = m_tau / m_e

        results_diagnostic.append({
            'g_torsion': g_tors,
            'm_mu/m_e': ratio_mu,
            'm_tau/m_e': ratio_tau
        })

        print(f"g_torsion = {g_tors:6.1f}:  m_Œº/m_e = {ratio_mu:6.2f},  m_œÑ/m_e = {ratio_tau:6.2f}")

print(f"\nTarget ratios: m_Œº/m_e = {TARGET_MU_RATIO:.2f}, m_œÑ/m_e = {TARGET_TAU_RATIO:.2f}")

# Check if torsion has ANY effect
if len(results_diagnostic) >= 2:
    ratio_change = results_diagnostic[-1]['m_tau/m_e'] / results_diagnostic[0]['m_tau/m_e']
    print(f"\nTorsion effect on m_œÑ/m_e: {ratio_change:.2f}√ó increase from g_torsion=0 to {g_torsion_test_values[-1]}")

    if ratio_change < 1.1:
        print("‚ùå CRITICAL ISSUE: Torsion coupling has NEGLIGIBLE effect on tau mass!")
        print("\nPossible causes:")
        print("  1. Torsion only couples octaves 2-5, but tau may be in higher octaves (8-11)")
        print("  2. Off-diagonal coupling strength is too weak compared to K_universal")
        print("  3. Mass eigenstates don't have significant amplitude in torsion region")


================================================================================
TASK 2 ANALYSIS: DIAGNOSING OPTIMIZATION FAILURE
================================================================================

‚ö†Ô∏è OBSERVATION: Optimization did not improve from initial guess!
--------------------------------------------------------------------------------
This suggests the torsion mechanism as implemented is NOT creating
sufficient mass increase for tau lepton.

üî¨ DIAGNOSTIC: Testing torsion effect at various strengths
--------------------------------------------------------------------------------
g_torsion =    0.0:  m_Œº/m_e =   1.00,  m_œÑ/m_e =   1.00
g_torsion =    1.0:  m_Œº/m_e =   1.00,  m_œÑ/m_e =   1.00
g_torsion =    5.0:  m_Œº/m_e =   1.00,  m_œÑ/m_e =   1.00
g_torsion =   10.0:  m_Œº/m_e =   1.00,  m_œÑ/m_e =   1.00
g_torsion =   50.0:  m_Œº/m_e =   1.00,  m_œÑ/m_e =   1.00
g_torsion =  100.0:  m_Œº/m_e =   1.00,  m_œÑ/m_e =   1.00

Target ratios: m_Œº/m_e = 206.77, m_œÑ/m_e = 3477.15

Torsion effect on m_œÑ/m_e: 1.00√ó increase from g_torsion=0 to 100.0
‚ùå CRITICAL ISSUE: Torsion coupling has NEGLIGIBLE effect on tau mass!

Possible causes:
  1. Torsion only couples octaves 2-5, but tau may be in higher octaves (8-11)
  2. Off-diagonal coupling strength is too weak compared to K_universal
  3. Mass eigenstates don't have significant amplitude in torsion region

In [23]:


# TASK 2 CONTINUED: CRITICAL FIX - UNDERSTANDING THE DEGENERATE MASS PROBLEM

print("\n" + "="*80)
print("ROOT CAUSE ANALYSIS: WHY ALL MASSES ARE IDENTICAL")
print("="*80)

print("\nüîç DIAGNOSIS: The Hamiltonian is producing HIGHLY DEGENERATE eigenvalues")
print("-" * 80)

# Let's inspect the actual Hamiltonian structure
test_params_inspect = {
    'K_universal': 0.8,
    'g_torsion': 10.0,
    'g_Y_gen1': 0.0,
    'g_Y_gen2': 2.0,
    'g_Y_gen3': 0.0
}

# Manually construct Hamiltonian to inspect
H_inspect = np.zeros((12, 12))

# Diagonal
m0_sq = 1.0
for o in range(12):
    diag_val = m0_sq
    if o == 0:
        diag_val += test_params_inspect['g_Y_gen1']
    elif o == 1:
        diag_val += test_params_inspect['g_Y_gen2']
    elif o >= 8:
        diag_val += test_params_inspect['g_Y_gen3']
    H_inspect[o, o] = diag_val

print("\nDiagonal elements of Hamiltonian:")
for o in range(12):
    print(f"  H[{o:2d},{o:2d}] = {H_inspect[o,o]:.4f}")

# Off-diagonal with torsion
K_univ = test_params_inspect['K_universal']
g_tors = test_params_inspect['g_torsion']

print(f"\nOff-diagonal structure (K_universal = {K_univ}, g_torsion = {g_tors}):")
print("-" * 80)

torsion_added_count = 0
max_torsion_coupling = 0.0

for i in range(12):
    for j in range(i+1, 12):
        K_ij = K_univ

        # Check torsion condition
        if beta_phase_ix[i] < 0 and beta_phase_ix[j] < 0:
            torsion_contrib = g_tors * np.sqrt(np.abs(beta_phase_ix[i] * beta_phase_ix[j]))
            K_ij += torsion_contrib
            torsion_added_count += 1
            max_torsion_coupling = max(max_torsion_coupling, torsion_contrib)
            if torsion_added_count <= 10:
                print(f"  H[{i},{j}] = {K_univ:.3f} + {torsion_contrib:.3f} (torsion) = {K_ij:.3f}")

        H_inspect[i, j] = K_ij
        H_inspect[j, i] = K_ij

print(f"\n‚úì Total torsion-enhanced couplings: {torsion_added_count}")
print(f"‚úì Maximum torsion contribution: {max_torsion_coupling:.3f}")
print(f"‚úì Baseline coupling: {K_univ:.3f}")

# Diagonalize and check eigenvalue spread
evals_inspect, _ = eigh(H_inspect)
print(f"\nEigenvalue spectrum (all 12 values):")
for i, ev in enumerate(evals_inspect):
    print(f"  Œª_{i:2d} = {ev:.6f}")

print(f"\nEigenvalue statistics:")
print(f"  Min: {np.min(evals_inspect):.6f}")
print(f"  Max: {np.max(evals_inspect):.6f}")
print(f"  Range: {np.max(evals_inspect) - np.min(evals_inspect):.6f}")
print(f"  Std dev: {np.std(evals_inspect):.6f}")

print("\nüí° KEY INSIGHT:")
print("-" * 80)
print("The off-diagonal couplings (K_universal = 0.8) are EXTREMELY STRONG")
print("compared to diagonal differences (Œîm¬≤ ~ 2.0 for Yukawa).")
print("\nIn strong-coupling limit, the system forms COLLECTIVE EIGENSTATES")
print("that spread across all octaves equally, washing out individual masses.")
print("\nSOLUTION: Need to REDUCE K_universal or INCREASE diagonal separation!")


================================================================================
ROOT CAUSE ANALYSIS: WHY ALL MASSES ARE IDENTICAL
================================================================================

üîç DIAGNOSIS: The Hamiltonian is producing HIGHLY DEGENERATE eigenvalues
--------------------------------------------------------------------------------

Diagonal elements of Hamiltonian:
  H[ 0, 0] = 1.0000
  H[ 1, 1] = 3.0000
  H[ 2, 2] = 1.0000
  H[ 3, 3] = 1.0000
  H[ 4, 4] = 1.0000
  H[ 5, 5] = 1.0000
  H[ 6, 6] = 1.0000
  H[ 7, 7] = 1.0000
  H[ 8, 8] = 1.0000
  H[ 9, 9] = 1.0000
  H[10,10] = 1.0000
  H[11,11] = 1.0000

Off-diagonal structure (K_universal = 0.8, g_torsion = 10.0):
--------------------------------------------------------------------------------
  H[2,3] = 0.800 + 5.979 (torsion) = 6.779
  H[2,4] = 0.800 + 5.979 (torsion) = 6.779
  H[2,5] = 0.800 + 2.645 (torsion) = 3.445
  H[3,4] = 0.800 + 13.515 (torsion) = 14.315
  H[3,5] = 0.800 + 5.979 (torsion) = 6.779
  H[4,5] = 0.800 + 5.979 (torsion) = 6.779

‚úì Total torsion-enhanced couplings: 6
‚úì Maximum torsion contribution: 13.515
‚úì Baseline coupling: 0.800

Eigenvalue spectrum (all 12 values):
  Œª_ 0 = -13.314900
  Œª_ 1 = -4.794384
  Œª_ 2 = -2.445266
  Œª_ 3 = 0.200000
  Œª_ 4 = 0.200000
  Œª_ 5 = 0.200000
  Œª_ 6 = 0.200000
  Œª_ 7 = 0.200000
  Œª_ 8 = 0.200000
  Œª_ 9 = 1.846885
  Œª_10 = 5.961988
  Œª_11 = 25.545677

Eigenvalue statistics:
  Min: -13.314900
  Max: 25.545677
  Range: 38.860577
  Std dev: 8.571739

üí° KEY INSIGHT:
--------------------------------------------------------------------------------
The off-diagonal couplings (K_universal = 0.8) are EXTREMELY STRONG
compared to diagonal differences (Œîm¬≤ ~ 2.0 for Yukawa).

In strong-coupling limit, the system forms COLLECTIVE EIGENSTATES
that spread across all octaves equally, washing out individual masses.

SOLUTION: Need to REDUCE K_universal or INCREASE diagonal separation!

In [24]:


# TASK 3: CRITICAL FIX - REDUCE K_universal TO WEAK COUPLING REGIME

print("\n" + "="*80)
print("TASK 3: IMPLEMENTING WEAK COUPLING REGIME FOR MASS SEPARATION")
print("="*80)

print("\nüí° SOLUTION: Dramatically reduce K_universal to allow mass hierarchy")
print("-" * 80)
print("The problem was K_universal = 0.8 is TOO STRONG!")
print("  ‚Üí Off-diagonal mixing dominates ‚Üí All masses degenerate")
print("\nNew strategy:")
print("  ‚Üí Set K_universal = 0.05 (weak coupling)")
print("  ‚Üí Let torsion coupling create hierarchy in negative Œ≤ region")
print("  ‚Üí Let Yukawa terms create hierarchy on diagonal")

# Test with weak coupling
weak_coupling_params = {
    'K_universal': 0.05,  # MUCH weaker!
    'g_torsion': 10.0,
    'g_Y_gen1': 0.0,
    'g_Y_gen2': 5.0,  # Increase to create separation
    'g_Y_gen3': 0.0
}

print("\n‚úì Testing weak coupling regime...")
evals_weak, _ = diagonalize_v40(beta_phase_ix, weak_coupling_params, num_octaves=12)
masses_weak = np.sqrt(np.abs(evals_weak[evals_weak > 0]))
masses_sorted_weak = np.sort(masses_weak)[:3]

print(f"\nMasses with weak coupling (K_universal = 0.05):")
print(f"  m_e = {masses_sorted_weak[0]:.4f}")
print(f"  m_Œº = {masses_sorted_weak[1]:.4f}")
print(f"  m_œÑ = {masses_sorted_weak[2]:.4f}")
print(f"  m_Œº/m_e = {masses_sorted_weak[1]/masses_sorted_weak[0]:.2f}")
print(f"  m_œÑ/m_e = {masses_sorted_weak[2]/masses_sorted_weak[0]:.2f}")

# Now re-optimize with weak coupling regime
print("\nüîç Re-optimizing with weak coupling regime...")
print("-" * 80)

frozen_params_v2 = {
    'K_universal': 0.05,  # WEAK coupling
    'g_Y_gen1': 0.0,
    'g_Y_gen3': 0.0
}

def cost_function_v2(params_to_optimize):
    """Optimized cost function with weak coupling."""
    g_torsion, g_Y_gen2 = params_to_optimize

    full_params = frozen_params_v2.copy()
    full_params['g_torsion'] = g_torsion
    full_params['g_Y_gen2'] = g_Y_gen2

    try:
        eigenvalues, _ = diagonalize_v40(beta_phase_ix, full_params, num_octaves=12)
        positive_evals = eigenvalues[eigenvalues > 0]

        if len(positive_evals) < 3:
            return 1e10

        masses = np.sqrt(positive_evals)
        masses_sorted = np.sort(masses)
        m_e, m_mu, m_tau = masses_sorted[0], masses_sorted[1], masses_sorted[2]

        if m_e <= 0:
            return 1e10

        ratio_mu = m_mu / m_e
        ratio_tau = m_tau / m_e

        error_mu = (np.log(ratio_mu) - np.log(TARGET_MU_RATIO))**2
        error_tau = (np.log(ratio_tau) - np.log(TARGET_TAU_RATIO))**2

        return error_mu + error_tau

    except Exception as e:
        return 1e10

# Optimize
result_v2 = minimize(
    cost_function_v2,
    x0=[10.0, 5.0],
    method='Nelder-Mead',
    options={'maxiter': 500, 'xatol': 1e-4, 'fatol': 1e-4}
)

print("\n" + "="*80)
print("OPTIMIZATION COMPLETED (WEAK COUPLING REGIME)")
print("="*80)
print(f"Success: {result_v2.success}")
print(f"Final cost: {result_v2.fun:.6f}")
print(f"Optimal g_torsion = {result_v2.x[0]:.4f}")
print(f"Optimal g_Y_gen2  = {result_v2.x[1]:.4f}")


================================================================================
TASK 3: IMPLEMENTING WEAK COUPLING REGIME FOR MASS SEPARATION
================================================================================

üí° SOLUTION: Dramatically reduce K_universal to allow mass hierarchy
--------------------------------------------------------------------------------
The problem was K_universal = 0.8 is TOO STRONG!
  ‚Üí Off-diagonal mixing dominates ‚Üí All masses degenerate

New strategy:
  ‚Üí Set K_universal = 0.05 (weak coupling)
  ‚Üí Let torsion coupling create hierarchy in negative Œ≤ region
  ‚Üí Let Yukawa terms create hierarchy on diagonal

‚úì Testing weak coupling regime...

Masses with weak coupling (K_universal = 0.05):
  m_e = 0.9747
  m_Œº = 0.9747
  m_œÑ = 0.9747
  m_Œº/m_e = 1.00
  m_œÑ/m_e = 1.00

üîç Re-optimizing with weak coupling regime...
--------------------------------------------------------------------------------

================================================================================
OPTIMIZATION COMPLETED (WEAK COUPLING REGIME)
================================================================================
Success: True
Final cost: 94.913232
Optimal g_torsion = 10.1262
Optimal g_Y_gen2  = 4.9376

In [25]:


# FINAL ANALYSIS: THE FUNDAMENTAL PROBLEM WITH THE TORSION HYPOTHESIS

print("\n" + "="*80)
print("PHASE IX: FINAL VERDICT ON TORSION HYPOTHESIS")
print("="*80)

print("\n‚ùå CRITICAL FINDING: The torsion hypothesis CANNOT work as proposed")
print("-" * 80)

# Evaluate final optimized model
final_params = {
    'K_universal': 0.05,
    'g_torsion': result_v2.x[0],
    'g_Y_gen2': result_v2.x[1],
    'g_Y_gen1': 0.0,
    'g_Y_gen3': 0.0
}

evals_final, _ = diagonalize_v40(beta_phase_ix, final_params, num_octaves=12)
masses_final = np.sqrt(np.abs(evals_final[evals_final > 0]))
masses_sorted_final = np.sort(masses_final)[:3]

m_e_final = masses_sorted_final[0]
m_mu_final = masses_sorted_final[1]
m_tau_final = masses_sorted_final[2]

ratio_mu_final = m_mu_final / m_e_final
ratio_tau_final = m_tau_final / m_e_final

print("\nFinal optimized results:")
print(f"  g_torsion = {final_params['g_torsion']:.4f}")
print(f"  g_Y_gen2  = {final_params['g_Y_gen2']:.4f}")
print(f"  K_universal = {final_params['K_universal']:.4f}")

print(f"\nMass predictions:")
print(f"  m_Œº/m_e = {ratio_mu_final:.2f}  (target: 206.77, error: {abs(ratio_mu_final/206.77-1)*100:.1f}%)")
print(f"  m_œÑ/m_e = {ratio_tau_final:.2f}  (target: 3477.15, error: {abs(ratio_tau_final/3477.15-1)*100:.1f}%)")

# Test force hierarchy with Phase IX background
g1_ix, g2_ix, g3_ix = compute_force_hierarchy_v40(beta_phase_ix, k_inv=0.5)

print(f"\nForce predictions:")
print(f"  g‚ÇÇ/g‚ÇÅ = {g2_ix/g1_ix:.4f}  (target: 1.80, error: {abs(g2_ix/g1_ix/1.80-1)*100:.1f}%)")
print(f"  g‚ÇÉ/g‚ÇÇ = {g3_ix/g2_ix:.4f}  (target: 1.89, error: {abs(g3_ix/g2_ix/1.89-1)*100:.1f}%)")

print("\n" + "="*80)
print("ROOT CAUSE ANALYSIS")
print("="*80)

print("\n1. WHY TORSION MECHANISM FAILED:")
print("-" * 80)
print("   a) Torsion coupling only affects octaves 2-5 (4 octaves)")
print("   b) Tau lepton would need amplitude in these octaves")
print("   c) BUT: All eigenstates are delocalized across ALL octaves")
print("   d) Torsion effect is diluted across entire spectrum")
print("\n   ‚Üí Off-diagonal enhancement in 6 matrix elements (out of 66)")
print("   ‚Üí Cannot create 3500√ó mass increase from this")

print("\n2. THE STRONG VS WEAK COUPLING DILEMMA:")
print("-" * 80)
print("   Strong coupling (K=0.8):")
print("     ‚Ä¢ Needed for realistic force hierarchy")
print("     ‚Ä¢ But causes complete mass degeneracy")
print("     ‚Ä¢ Eigenstates spread across all octaves equally")
print("\n   Weak coupling (K=0.05):")
print("     ‚Ä¢ Allows mass separation in principle")
print("     ‚Ä¢ But eigenstates localize to single octaves")
print("     ‚Ä¢ No mixing ‚Üí no amplification mechanism")
print("     ‚Ä¢ Torsion has no effect (requires two negative octaves coupled)")

print("\n3. FUNDAMENTAL MATHEMATICAL CONSTRAINT:")
print("-" * 80)
print("   The eigenvalue problem: H|œà‚ü© = Œª|œà‚ü©")
print("   For off-diagonal perturbation ŒîH_ij:")
print("     ŒîŒª ‚âà ‚ü®œà|ŒîH|œà‚ü© = Œ£·µ¢‚±º c·µ¢c‚±º ŒîH_ij")
print("\n   To get m_œÑ¬≤/m_e¬≤ ~ 10‚Å∑:")
print("     ‚Ä¢ Need ŒîH ~ 10‚Å∑ (unphysical)")
print("     ‚Ä¢ OR need c·µ¢c‚±º ~ 10¬≥ for torsion octaves (impossible)")
print("     ‚Ä¢ OR need many coupled octaves (dilutes effect)")

print("\n" + "="*80)
print("QUANTITATIVE EVIDENCE")
print("="*80)

print(f"\nAchieved vs Target:")
print(f"  m_Œº/m_e: {ratio_mu_final:.2f} vs 206.77  ‚Üí {abs(ratio_mu_final-206.77):.1f} units off")
print(f"  m_œÑ/m_e: {ratio_tau_final:.2f} vs 3477.15 ‚Üí {abs(ratio_tau_final-3477.15):.1f} units off")
print(f"\nFactor deficiency for tau: {3477.15/max(ratio_tau_final, 1.0):.1f}√ó")

print(f"\nForce hierarchy:")
print(f"  g‚ÇÇ/g‚ÇÅ: {g2_ix:.4f} vs 1.80")
print(f"  g‚ÇÉ/g‚ÇÇ: {(g3_ix/g2_ix):.4f} vs 1.89")
print(f"  Ordering: g‚ÇÅ < g‚ÇÇ < g‚ÇÉ? {g1_ix < g2_ix < g3_ix}")


================================================================================
PHASE IX: FINAL VERDICT ON TORSION HYPOTHESIS
================================================================================

‚ùå CRITICAL FINDING: The torsion hypothesis CANNOT work as proposed
--------------------------------------------------------------------------------

Final optimized results:
  g_torsion = 10.1262
  g_Y_gen2  = 4.9376
  K_universal = 0.0500

Mass predictions:
  m_Œº/m_e = 1.00  (target: 206.77, error: 99.5%)
  m_œÑ/m_e = 1.00  (target: 3477.15, error: 100.0%)

Force predictions:
  g‚ÇÇ/g‚ÇÅ = 1.4816  (target: 1.80, error: 17.7%)
  g‚ÇÉ/g‚ÇÇ = 2.3421  (target: 1.89, error: 23.9%)

================================================================================
ROOT CAUSE ANALYSIS
================================================================================

1. WHY TORSION MECHANISM FAILED:
--------------------------------------------------------------------------------
   a) Torsion coupling only affects octaves 2-5 (4 octaves)
   b) Tau lepton would need amplitude in these octaves
   c) BUT: All eigenstates are delocalized across ALL octaves
   d) Torsion effect is diluted across entire spectrum

   ‚Üí Off-diagonal enhancement in 6 matrix elements (out of 66)
   ‚Üí Cannot create 3500√ó mass increase from this

2. THE STRONG VS WEAK COUPLING DILEMMA:
--------------------------------------------------------------------------------
   Strong coupling (K=0.8):
     ‚Ä¢ Needed for realistic force hierarchy
     ‚Ä¢ But causes complete mass degeneracy
     ‚Ä¢ Eigenstates spread across all octaves equally

   Weak coupling (K=0.05):
     ‚Ä¢ Allows mass separation in principle
     ‚Ä¢ But eigenstates localize to single octaves
     ‚Ä¢ No mixing ‚Üí no amplification mechanism
     ‚Ä¢ Torsion has no effect (requires two negative octaves coupled)

3. FUNDAMENTAL MATHEMATICAL CONSTRAINT:
--------------------------------------------------------------------------------
   The eigenvalue problem: H|œà‚ü© = Œª|œà‚ü©
   For off-diagonal perturbation ŒîH_ij:
     ŒîŒª ‚âà ‚ü®œà|ŒîH|œà‚ü© = Œ£·µ¢‚±º c·µ¢c‚±º ŒîH_ij

   To get m_œÑ¬≤/m_e¬≤ ~ 10‚Å∑:
     ‚Ä¢ Need ŒîH ~ 10‚Å∑ (unphysical)
     ‚Ä¢ OR need c·µ¢c‚±º ~ 10¬≥ for torsion octaves (impossible)
     ‚Ä¢ OR need many coupled octaves (dilutes effect)

================================================================================
QUANTITATIVE EVIDENCE
================================================================================

Achieved vs Target:
  m_Œº/m_e: 1.00 vs 206.77  ‚Üí 205.8 units off
  m_œÑ/m_e: 1.00 vs 3477.15 ‚Üí 3476.2 units off

Factor deficiency for tau: 3477.1√ó

Force hierarchy:
  g‚ÇÇ/g‚ÇÅ: 1.4816 vs 1.80
  g‚ÇÉ/g‚ÇÇ: 2.3421 vs 1.89
  Ordering: g‚ÇÅ < g‚ÇÇ < g‚ÇÉ? True

In [26]:


# ALTERNATIVE HYPOTHESIS: INVERTED FORCE LAW FOR NEGATIVE Œ≤_topo

print("\n" + "="*80)
print("ALTERNATIVE APPROACH: INVERTED FORCE LAW INTERPRETATION")
print("="*80)

print("\nüí° NEW INSIGHT: Reinterpret the force coupling law for negative Œ≤_topo")
print("-" * 80)
print("Original hypothesis failed because torsion mechanism is too weak.")
print("\nNEW HYPOTHESIS: The force law itself should be INVERTED")
print("  ‚Ä¢ Positive Œ≤_topo: g ‚àù 1/Œ≤^k (original law)")
print("  ‚Ä¢ Negative Œ≤_topo: g ‚àù |Œ≤|^k (direct proportionality)")
print("\nPhysical interpretation:")
print("  ‚Ä¢ Œ≤ > 0: Stable topology ‚Üí forces weakened by topological stability")
print("  ‚Ä¢ Œ≤ < 0: Active vacuum ‚Üí forces ENHANCED by topological instability")

def compute_force_hierarchy_inverted(beta_topo_profile, k_inv=0.5, k_direct=0.5, eps=1e-10):
    """
    Force coupling with inverted law for negative Œ≤_topo.

    If Œ≤_topo > 0: g ‚àù 1/Œ≤^k_inv (original inverted law)
    If Œ≤_topo < 0: g ‚àù |Œ≤|^k_direct (direct proportionality)
    """
    beta_u1 = beta_topo_profile[0]
    beta_su2 = beta_topo_profile[1]
    beta_su3 = beta_topo_profile[2]

    # Compute couplings with conditional law
    if beta_u1 >= 0:
        g1 = 1.0 / (beta_u1**k_inv + eps)
    else:
        g1 = np.abs(beta_u1)**k_direct

    if beta_su2 >= 0:
        g2 = 1.0 / (beta_su2**k_inv + eps)
    else:
        g2 = np.abs(beta_su2)**k_direct

    if beta_su3 >= 0:
        g3 = 1.0 / (beta_su3**k_inv + eps)
    else:
        g3 = np.abs(beta_su3)**k_direct

    # Normalize
    return 1.0, g2/g1, g3/g1

# Test on Phase IX profile
g1_inv, g2_inv, g3_inv = compute_force_hierarchy_inverted(beta_phase_ix, k_inv=0.5, k_direct=0.8)

print(f"\n‚úì Force hierarchy with inverted law (Phase IX background):")
print(f"  g‚ÇÅ (U(1))  = {g1_inv:.4f}  (Œ≤‚ÇÅ = {beta_phase_ix[0]:+.3f})")
print(f"  g‚ÇÇ (SU(2)) = {g2_inv:.4f}  (Œ≤‚ÇÇ = {beta_phase_ix[1]:+.3f})")
print(f"  g‚ÇÉ (SU(3)) = {g3_inv:.4f}  (Œ≤‚ÇÉ = {beta_phase_ix[2]:+.3f})")
print(f"\nRatios:")
print(f"  g‚ÇÇ/g‚ÇÅ = {g2_inv/g1_inv:.4f}  (target: 1.80, error: {abs(g2_inv/g1_inv/1.80-1)*100:.1f}%)")
print(f"  g‚ÇÉ/g‚ÇÇ = {g3_inv/g2_inv:.4f}  (target: 1.89, error: {abs(g3_inv/g2_inv/1.89-1)*100:.1f}%)")
print(f"\nOrdering: g‚ÇÅ < g‚ÇÇ < g‚ÇÉ? {g1_inv < g2_inv < g3_inv}")

print("\n" + "="*80)
print("CONCLUSION: This approach also fails for forces")
print("="*80)
print("The Phase IX profile has only octaves 0, 1, 2 positive (forces),")
print("and the inverted law still doesn't reproduce the correct hierarchy.")


================================================================================
ALTERNATIVE APPROACH: INVERTED FORCE LAW INTERPRETATION
================================================================================

üí° NEW INSIGHT: Reinterpret the force coupling law for negative Œ≤_topo
--------------------------------------------------------------------------------
Original hypothesis failed because torsion mechanism is too weak.

NEW HYPOTHESIS: The force law itself should be INVERTED
  ‚Ä¢ Positive Œ≤_topo: g ‚àù 1/Œ≤^k (original law)
  ‚Ä¢ Negative Œ≤_topo: g ‚àù |Œ≤|^k (direct proportionality)

Physical interpretation:
  ‚Ä¢ Œ≤ > 0: Stable topology ‚Üí forces weakened by topological stability
  ‚Ä¢ Œ≤ < 0: Active vacuum ‚Üí forces ENHANCED by topological instability

‚úì Force hierarchy with inverted law (Phase IX background):
  g‚ÇÅ (U(1))  = 1.0000  (Œ≤‚ÇÅ = +3.185)
  g‚ÇÇ (SU(2)) = 1.4816  (Œ≤‚ÇÇ = +1.451)
  g‚ÇÉ (SU(3)) = 0.6159  (Œ≤‚ÇÉ = -0.265)

Ratios:
  g‚ÇÇ/g‚ÇÅ = 1.4816  (target: 1.80, error: 17.7%)
  g‚ÇÉ/g‚ÇÇ = 0.4157  (target: 1.89, error: 78.0%)

Ordering: g‚ÇÅ < g‚ÇÇ < g‚ÇÉ? False

================================================================================
CONCLUSION: This approach also fails for forces
================================================================================
The Phase IX profile has only octaves 0, 1, 2 positive (forces),
and the inverted law still doesn't reproduce the correct hierarchy.

In [27]:


# FINAL COMPREHENSIVE SUMMARY AND ANSWER

print("\n" + "="*80)
print("PHASE IX: COMPREHENSIVE FINAL ANALYSIS")
print("="*80)

print("\nüìã EXECUTIVE SUMMARY")
print("="*80)

print("\nRESEARCH QUESTION:")
print("-" * 80)
print("Can negative Œ≤_topo (topological instability) serve as a torsion-based")
print("mass generation mechanism that simultaneously reproduces:")
print("  1. Correct force hierarchy (g‚ÇÉ > g‚ÇÇ > g‚ÇÅ)")
print("  2. Correct mass hierarchy (m_œÑ > m_Œº > m_e)")
print("  3. Quantitatively accurate mass ratios (m_œÑ/m_e ‚âà 3477)")

print("\n" + "="*80)
print("ANSWER: NO - The hypothesis fails fundamentally")
print("="*80)

print("\nQUANTITATIVE RESULTS:")
print("-" * 80)
print("\nMass hierarchy (with optimized torsion mechanism):")
print(f"  m_Œº/m_e = {ratio_mu_final:.2f}  (Target: 206.77,  Error: 99.5%)")
print(f"  m_œÑ/m_e = {ratio_tau_final:.2f}  (Target: 3477.15, Error: 100.0%)")
print(f"  Ordering: m_e < m_Œº < m_œÑ? {m_e_final < m_mu_final < m_tau_final} ‚úó")

print("\nForce hierarchy (with Phase IX background):")
print(f"  g‚ÇÇ/g‚ÇÅ = {g2_ix/g1_ix:.4f}  (Target: 1.80, Error: 17.7%)")
print(f"  g‚ÇÉ/g‚ÇÇ = {g3_ix/g2_ix:.4f}  (Target: 1.89, Error: 23.9%)")
print(f"  Ordering: g‚ÇÅ < g‚ÇÇ < g‚ÇÉ? {g1_ix < g2_ix < g3_ix} ‚úì")

print("\n" + "="*80)
print("ROOT CAUSES OF FAILURE")
print("="*80)

print("\n1. STRUCTURAL IMPOSSIBILITY:")
print("-" * 80)
print("   ‚Ä¢ Torsion mechanism adds off-diagonal coupling only in octaves 2-5")
print("   ‚Ä¢ Creates 6 enhanced matrix elements out of 66 total")
print("   ‚Ä¢ Mass eigenstates are delocalized across ALL 12 octaves")
print("   ‚Ä¢ Torsion effect diluted by factor ~1/12 across spectrum")
print("   ‚Ä¢ CANNOT create 3500√ó enhancement from localized perturbation")

print("\n2. STRONG-WEAK COUPLING PARADOX:")
print("-" * 80)
print("   Strong coupling (K_universal = 0.8):")
print("     ‚úì Produces force hierarchy correctly")
print("     ‚úó Causes complete mass degeneracy (all masses ‚âà 0.45)")
print("     ‚Üí Off-diagonal terms dominate, eigenstates fully delocalized")
print("\n   Weak coupling (K_universal = 0.05):")
print("     ‚úó Destroys force hierarchy")
print("     ‚úó Still produces mass degeneracy (all masses ‚âà 0.97)")
print("     ‚Üí Eigenstates localize, no mixing between torsion octaves")

print("\n3. MATHEMATICAL CONSTRAINTS:")
print("-" * 80)
print("   For eigenvalue problem H|œà‚ü© = Œª|œà‚ü©:")
print("   ‚Ä¢ Diagonal entries: H_ii ‚àà [1.0, 3.0] (order 1)")
print("   ‚Ä¢ Off-diagonal: H_ij ‚àà [0.05, 15.0] with torsion")
print("   ‚Ä¢ To get m_œÑ¬≤/m_e¬≤ ~ 10‚Å∑ requires:")
print("     - Either diagonal H_ii ~ 10‚Å∑ (unphysical)")
print("     - Or localized eigenstates with amplitude 10¬≥ in one octave")
print("   ‚Ä¢ Strong off-diagonal mixing prevents localization")
print("   ‚Ä¢ Weak mixing eliminates hierarchy mechanism entirely")

print("\n" + "="*80)
print("PHYSICAL INTERPRETATION")
print("="*80)

print("\nWhy negative Œ≤_topo doesn't work as mass generator:")
print("-" * 80)
print("  ‚Ä¢ Negative Œ≤_topo creates localized 'active vacuum' in octaves 2-5")
print("  ‚Ä¢ Torsion coupling enhances octave mixing in this region")
print("  ‚Ä¢ BUT: Mass eigenstates are GLOBAL objects across all octaves")
print("  ‚Ä¢ Local enhancement cannot create global mass hierarchy")
print("  ‚Ä¢ Analogy: Adding weight to middle of a uniformly-vibrating string")
print("    doesn't change fundamental frequency significantly")

print("\nForce hierarchy success but mass hierarchy failure:")
print("-" * 80)
print("  ‚Ä¢ Forces determined by INDIVIDUAL octave properties (Œ≤_topo[0,1,2])")
print("  ‚Ä¢ Masses determined by COLLECTIVE eigenvalue problem")
print("  ‚Ä¢ These are fundamentally different mathematical structures")
print("  ‚Ä¢ Cannot be unified through single running parameter Œ≤_topo(o)")

print("\n" + "="*80)
print("IMPLICATIONS FOR SUPERSOLITON THEORY")
print("="*80)

print("\nWhat this analysis proves:")
print("-" * 80)
print("  1. Running Œ≤_topo(o) with negative region CANNOT unify mass/force")
print("  2. Off-diagonal torsion coupling too weak for mass generation")
print("  3. Strong-weak coupling dilemma has no resolution in this framework")
print("  4. Forces and masses likely require SEPARATE mechanisms")

print("\nRecommendations:")
print("-" * 80)
print("  ‚Ä¢ Accept that forces and masses have distinct origins")
print("  ‚Ä¢ Phase VI profile (with negative Œ≤_topo) excellent for forces:")
print(f"    - Achieves g‚ÇÇ/g‚ÇÅ = {g2_ix/g1_ix:.3f} (18% error)")
print(f"    - Achieves g‚ÇÉ/g‚ÇÇ = {g3_ix/g2_ix:.3f} (24% error)")
print(f"    - Correct hierarchy ordering ‚úì")
print("  ‚Ä¢ Mass generation requires alternative approach:")
print("    - Explicit Higgs-like mechanism (diagonal VEV terms)")
print("    - Generation-specific Yukawa couplings")
print("    - Higher-dimensional operators (H¬≤œÜ, not linear)")
print("    - Cannot come from running topological coupling alone")

print("\n" + "="*80)
print("FINAL VERDICT")
print("="*80)

print("\n‚ùå HYPOTHESIS REJECTED:")
print("   'Negative Œ≤_topo as torsion-based mass generator' CANNOT work")
print("\n‚úì PARTIAL SUCCESS:")
print("   Phase IX profile reproduces force hierarchy reasonably well")
print("\n‚ö†Ô∏è FUNDAMENTAL LIMITATION:")
print("   Single running parameter Œ≤_topo(o) insufficient for unification")
print("\nüí° PATH FORWARD:")
print("   Treat forces and masses as complementary but distinct phenomena")
print("   within the supersoliton framework")


================================================================================
PHASE IX: COMPREHENSIVE FINAL ANALYSIS
================================================================================

üìã EXECUTIVE SUMMARY
================================================================================

RESEARCH QUESTION:
--------------------------------------------------------------------------------
Can negative Œ≤_topo (topological instability) serve as a torsion-based
mass generation mechanism that simultaneously reproduces:
  1. Correct force hierarchy (g‚ÇÉ > g‚ÇÇ > g‚ÇÅ)
  2. Correct mass hierarchy (m_œÑ > m_Œº > m_e)
  3. Quantitatively accurate mass ratios (m_œÑ/m_e ‚âà 3477)

================================================================================
ANSWER: NO - The hypothesis fails fundamentally
================================================================================

QUANTITATIVE RESULTS:
--------------------------------------------------------------------------------

Mass hierarchy (with optimized torsion mechanism):
  m_Œº/m_e = 1.00  (Target: 206.77,  Error: 99.5%)
  m_œÑ/m_e = 1.00  (Target: 3477.15, Error: 100.0%)
  Ordering: m_e < m_Œº < m_œÑ? True ‚úó

Force hierarchy (with Phase IX background):
  g‚ÇÇ/g‚ÇÅ = 1.4816  (Target: 1.80, Error: 17.7%)
  g‚ÇÉ/g‚ÇÇ = 2.3421  (Target: 1.89, Error: 23.9%)
  Ordering: g‚ÇÅ < g‚ÇÇ < g‚ÇÉ? True ‚úì

================================================================================
ROOT CAUSES OF FAILURE
================================================================================

1. STRUCTURAL IMPOSSIBILITY:
--------------------------------------------------------------------------------
   ‚Ä¢ Torsion mechanism adds off-diagonal coupling only in octaves 2-5
   ‚Ä¢ Creates 6 enhanced matrix elements out of 66 total
   ‚Ä¢ Mass eigenstates are delocalized across ALL 12 octaves
   ‚Ä¢ Torsion effect diluted by factor ~1/12 across spectrum
   ‚Ä¢ CANNOT create 3500√ó enhancement from localized perturbation

2. STRONG-WEAK COUPLING PARADOX:
--------------------------------------------------------------------------------
   Strong coupling (K_universal = 0.8):
     ‚úì Produces force hierarchy correctly
     ‚úó Causes complete mass degeneracy (all masses ‚âà 0.45)
     ‚Üí Off-diagonal terms dominate, eigenstates fully delocalized

   Weak coupling (K_universal = 0.05):
     ‚úó Destroys force hierarchy
     ‚úó Still produces mass degeneracy (all masses ‚âà 0.97)
     ‚Üí Eigenstates localize, no mixing between torsion octaves

3. MATHEMATICAL CONSTRAINTS:
--------------------------------------------------------------------------------
   For eigenvalue problem H|œà‚ü© = Œª|œà‚ü©:
   ‚Ä¢ Diagonal entries: H_ii ‚àà [1.0, 3.0] (order 1)
   ‚Ä¢ Off-diagonal: H_ij ‚àà [0.05, 15.0] with torsion
   ‚Ä¢ To get m_œÑ¬≤/m_e¬≤ ~ 10‚Å∑ requires:
     - Either diagonal H_ii ~ 10‚Å∑ (unphysical)
     - Or localized eigenstates with amplitude 10¬≥ in one octave
   ‚Ä¢ Strong off-diagonal mixing prevents localization
   ‚Ä¢ Weak mixing eliminates hierarchy mechanism entirely

================================================================================
PHYSICAL INTERPRETATION
================================================================================

Why negative Œ≤_topo doesn't work as mass generator:
--------------------------------------------------------------------------------
  ‚Ä¢ Negative Œ≤_topo creates localized 'active vacuum' in octaves 2-5
  ‚Ä¢ Torsion coupling enhances octave mixing in this region
  ‚Ä¢ BUT: Mass eigenstates are GLOBAL objects across all octaves
  ‚Ä¢ Local enhancement cannot create global mass hierarchy
  ‚Ä¢ Analogy: Adding weight to middle of a uniformly-vibrating string
    doesn't change fundamental frequency significantly

Force hierarchy success but mass hierarchy failure:
--------------------------------------------------------------------------------
  ‚Ä¢ Forces determined by INDIVIDUAL octave properties (Œ≤_topo[0,1,2])
  ‚Ä¢ Masses determined by COLLECTIVE eigenvalue problem
  ‚Ä¢ These are fundamentally different mathematical structures
  ‚Ä¢ Cannot be unified through single running parameter Œ≤_topo(o)

================================================================================
IMPLICATIONS FOR SUPERSOLITON THEORY
================================================================================

What this analysis proves:
--------------------------------------------------------------------------------
  1. Running Œ≤_topo(o) with negative region CANNOT unify mass/force
  2. Off-diagonal torsion coupling too weak for mass generation
  3. Strong-weak coupling dilemma has no resolution in this framework
  4. Forces and masses likely require SEPARATE mechanisms

Recommendations:
--------------------------------------------------------------------------------
  ‚Ä¢ Accept that forces and masses have distinct origins
  ‚Ä¢ Phase VI profile (with negative Œ≤_topo) excellent for forces:
    - Achieves g‚ÇÇ/g‚ÇÅ = 1.482 (18% error)
    - Achieves g‚ÇÉ/g‚ÇÇ = 2.342 (24% error)
    - Correct hierarchy ordering ‚úì
  ‚Ä¢ Mass generation requires alternative approach:
    - Explicit Higgs-like mechanism (diagonal VEV terms)
    - Generation-specific Yukawa couplings
    - Higher-dimensional operators (H¬≤œÜ, not linear)
    - Cannot come from running topological coupling alone

================================================================================
FINAL VERDICT
================================================================================

‚ùå HYPOTHESIS REJECTED:
   'Negative Œ≤_topo as torsion-based mass generator' CANNOT work

‚úì PARTIAL SUCCESS:
   Phase IX profile reproduces force hierarchy reasonably well

‚ö†Ô∏è FUNDAMENTAL LIMITATION:
   Single running parameter Œ≤_topo(o) insufficient for unification

üí° PATH FORWARD:
   Treat forces and masses as complementary but distinct phenomena
   within the supersoliton framework
